//
// Autogenerated by Thrift Compiler (0.7.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
var Thrift = require('helenus-thrift').Thrift;

var ttypes = require('./cassandra_types');
//HELPER FUNCTIONS AND STRUCTURES

var Cassandra_login_args = function(args) {
  this.auth_request = null;
  if (args) {
    if (args.auth_request !== undefined) {
      this.auth_request = args.auth_request;
    }
  }
};
Cassandra_login_args.prototype = {};
Cassandra_login_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.auth_request = new ttypes.AuthenticationRequest();
        this.auth_request.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_login_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_login_args');
  if (this.auth_request) {
    output.writeFieldBegin('auth_request', Thrift.Type.STRUCT, 1);
    this.auth_request.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_login_result = function(args) {
  this.authnx = null;
  this.authzx = null;
  if (args) {
    if (args.authnx !== undefined) {
      this.authnx = args.authnx;
    }
    if (args.authzx !== undefined) {
      this.authzx = args.authzx;
    }
  }
};
Cassandra_login_result.prototype = {};
Cassandra_login_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.authnx = new ttypes.AuthenticationException();
        this.authnx.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.authzx = new ttypes.AuthorizationException();
        this.authzx.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_login_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_login_result');
  if (this.authnx) {
    output.writeFieldBegin('authnx', Thrift.Type.STRUCT, 1);
    this.authnx.write(output);
    output.writeFieldEnd();
  }
  if (this.authzx) {
    output.writeFieldBegin('authzx', Thrift.Type.STRUCT, 2);
    this.authzx.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_set_keyspace_args = function(args) {
  this.keyspace = null;
  if (args) {
    if (args.keyspace !== undefined) {
      this.keyspace = args.keyspace;
    }
  }
};
Cassandra_set_keyspace_args.prototype = {};
Cassandra_set_keyspace_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.keyspace = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_set_keyspace_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_set_keyspace_args');
  if (this.keyspace) {
    output.writeFieldBegin('keyspace', Thrift.Type.STRING, 1);
    output.writeString(this.keyspace);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_set_keyspace_result = function(args) {
  this.ire = null;
  if (args) {
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
  }
};
Cassandra_set_keyspace_result.prototype = {};
Cassandra_set_keyspace_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_set_keyspace_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_set_keyspace_result');
  if (this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_get_args = function(args) {
  this.key = null;
  this.column_path = null;
  this.consistency_level = 1;
  if (args) {
    if (args.key !== undefined) {
      this.key = args.key;
    }
    if (args.column_path !== undefined) {
      this.column_path = args.column_path;
    }
    if (args.consistency_level !== undefined) {
      this.consistency_level = args.consistency_level;
    }
  }
};
Cassandra_get_args.prototype = {};
Cassandra_get_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.key = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.column_path = new ttypes.ColumnPath();
        this.column_path.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_get_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_get_args');
  if (this.key) {
    output.writeFieldBegin('key', Thrift.Type.STRING, 1);
    output.writeString(this.key);
    output.writeFieldEnd();
  }
  if (this.column_path) {
    output.writeFieldBegin('column_path', Thrift.Type.STRUCT, 2);
    this.column_path.write(output);
    output.writeFieldEnd();
  }
  if (this.consistency_level) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 3);
    output.writeI32(this.consistency_level);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_get_result = function(args) {
  this.success = null;
  this.ire = null;
  this.nfe = null;
  this.ue = null;
  this.te = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.nfe !== undefined) {
      this.nfe = args.nfe;
    }
    if (args.ue !== undefined) {
      this.ue = args.ue;
    }
    if (args.te !== undefined) {
      this.te = args.te;
    }
  }
};
Cassandra_get_result.prototype = {};
Cassandra_get_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.STRUCT) {
        this.success = new ttypes.ColumnOrSuperColumn();
        this.success.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.nfe = new ttypes.NotFoundException();
        this.nfe.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException();
        this.ue.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException();
        this.te.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_get_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_get_result');
  if (this.success) {
    output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
    this.success.write(output);
    output.writeFieldEnd();
  }
  if (this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.nfe) {
    output.writeFieldBegin('nfe', Thrift.Type.STRUCT, 2);
    this.nfe.write(output);
    output.writeFieldEnd();
  }
  if (this.ue) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 3);
    this.ue.write(output);
    output.writeFieldEnd();
  }
  if (this.te) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 4);
    this.te.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_get_slice_args = function(args) {
  this.key = null;
  this.column_parent = null;
  this.predicate = null;
  this.consistency_level = 1;
  if (args) {
    if (args.key !== undefined) {
      this.key = args.key;
    }
    if (args.column_parent !== undefined) {
      this.column_parent = args.column_parent;
    }
    if (args.predicate !== undefined) {
      this.predicate = args.predicate;
    }
    if (args.consistency_level !== undefined) {
      this.consistency_level = args.consistency_level;
    }
  }
};
Cassandra_get_slice_args.prototype = {};
Cassandra_get_slice_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.key = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.column_parent = new ttypes.ColumnParent();
        this.column_parent.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.predicate = new ttypes.SlicePredicate();
        this.predicate.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_get_slice_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_get_slice_args');
  if (this.key) {
    output.writeFieldBegin('key', Thrift.Type.STRING, 1);
    output.writeString(new Buffer(this.key, 'binary'));
    output.writeFieldEnd();
  }
  if (this.column_parent) {
    output.writeFieldBegin('column_parent', Thrift.Type.STRUCT, 2);
    this.column_parent.write(output);
    output.writeFieldEnd();
  }
  if (this.predicate) {
    output.writeFieldBegin('predicate', Thrift.Type.STRUCT, 3);
    this.predicate.write(output);
    output.writeFieldEnd();
  }
  if (this.consistency_level) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 4);
    output.writeI32(this.consistency_level);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_get_slice_result = function(args) {
  this.success = null;
  this.ire = null;
  this.ue = null;
  this.te = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.ue !== undefined) {
      this.ue = args.ue;
    }
    if (args.te !== undefined) {
      this.te = args.te;
    }
  }
};
Cassandra_get_slice_result.prototype = {};
Cassandra_get_slice_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.LIST) {
        var _size190 = 0;
        var _rtmp3194;
        this.success = [];
        var _etype193 = 0;
        _rtmp3194 = input.readListBegin();
        _etype193 = _rtmp3194.etype;
        _size190 = _rtmp3194.size;
        for (var _i195 = 0; _i195 < _size190; ++_i195)
        {
          var elem196 = null;
          elem196 = new ttypes.ColumnOrSuperColumn();
          elem196.read(input);
          this.success.push(elem196);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException();
        this.ue.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException();
        this.te.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_get_slice_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_get_slice_result');
  if (this.success) {
    output.writeFieldBegin('success', Thrift.Type.LIST, 0);
    output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
    for (var iter197 in this.success)
    {
      if (this.success.hasOwnProperty(iter197))
      {
        iter197 = this.success[iter197];
        iter197.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.ue) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2);
    this.ue.write(output);
    output.writeFieldEnd();
  }
  if (this.te) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3);
    this.te.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_get_count_args = function(args) {
  this.key = null;
  this.column_parent = null;
  this.predicate = null;
  this.consistency_level = 1;
  if (args) {
    if (args.key !== undefined) {
      this.key = args.key;
    }
    if (args.column_parent !== undefined) {
      this.column_parent = args.column_parent;
    }
    if (args.predicate !== undefined) {
      this.predicate = args.predicate;
    }
    if (args.consistency_level !== undefined) {
      this.consistency_level = args.consistency_level;
    }
  }
};
Cassandra_get_count_args.prototype = {};
Cassandra_get_count_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.key = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.column_parent = new ttypes.ColumnParent();
        this.column_parent.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.predicate = new ttypes.SlicePredicate();
        this.predicate.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_get_count_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_get_count_args');
  if (this.key) {
    output.writeFieldBegin('key', Thrift.Type.STRING, 1);
    output.writeString(this.key);
    output.writeFieldEnd();
  }
  if (this.column_parent) {
    output.writeFieldBegin('column_parent', Thrift.Type.STRUCT, 2);
    this.column_parent.write(output);
    output.writeFieldEnd();
  }
  if (this.predicate) {
    output.writeFieldBegin('predicate', Thrift.Type.STRUCT, 3);
    this.predicate.write(output);
    output.writeFieldEnd();
  }
  if (this.consistency_level) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 4);
    output.writeI32(this.consistency_level);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_get_count_result = function(args) {
  this.success = null;
  this.ire = null;
  this.ue = null;
  this.te = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.ue !== undefined) {
      this.ue = args.ue;
    }
    if (args.te !== undefined) {
      this.te = args.te;
    }
  }
};
Cassandra_get_count_result.prototype = {};
Cassandra_get_count_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.I32) {
        this.success = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException();
        this.ue.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException();
        this.te.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_get_count_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_get_count_result');
  if (this.success) {
    output.writeFieldBegin('success', Thrift.Type.I32, 0);
    output.writeI32(this.success);
    output.writeFieldEnd();
  }
  if (this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.ue) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2);
    this.ue.write(output);
    output.writeFieldEnd();
  }
  if (this.te) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3);
    this.te.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_multiget_slice_args = function(args) {
  this.keys = null;
  this.column_parent = null;
  this.predicate = null;
  this.consistency_level = 1;
  if (args) {
    if (args.keys !== undefined) {
      this.keys = args.keys;
    }
    if (args.column_parent !== undefined) {
      this.column_parent = args.column_parent;
    }
    if (args.predicate !== undefined) {
      this.predicate = args.predicate;
    }
    if (args.consistency_level !== undefined) {
      this.consistency_level = args.consistency_level;
    }
  }
};
Cassandra_multiget_slice_args.prototype = {};
Cassandra_multiget_slice_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.LIST) {
        var _size198 = 0;
        var _rtmp3202;
        this.keys = [];
        var _etype201 = 0;
        _rtmp3202 = input.readListBegin();
        _etype201 = _rtmp3202.etype;
        _size198 = _rtmp3202.size;
        for (var _i203 = 0; _i203 < _size198; ++_i203)
        {
          var elem204 = null;
          elem204 = input.readString();
          this.keys.push(elem204);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.column_parent = new ttypes.ColumnParent();
        this.column_parent.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.predicate = new ttypes.SlicePredicate();
        this.predicate.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_multiget_slice_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_multiget_slice_args');
  if (this.keys) {
    output.writeFieldBegin('keys', Thrift.Type.LIST, 1);
    output.writeListBegin(Thrift.Type.STRING, this.keys.length);
    for (var iter205 in this.keys)
    {
      if (this.keys.hasOwnProperty(iter205))
      {
        iter205 = this.keys[iter205];
        output.writeString(iter205);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.column_parent) {
    output.writeFieldBegin('column_parent', Thrift.Type.STRUCT, 2);
    this.column_parent.write(output);
    output.writeFieldEnd();
  }
  if (this.predicate) {
    output.writeFieldBegin('predicate', Thrift.Type.STRUCT, 3);
    this.predicate.write(output);
    output.writeFieldEnd();
  }
  if (this.consistency_level) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 4);
    output.writeI32(this.consistency_level);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_multiget_slice_result = function(args) {
  this.success = null;
  this.ire = null;
  this.ue = null;
  this.te = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.ue !== undefined) {
      this.ue = args.ue;
    }
    if (args.te !== undefined) {
      this.te = args.te;
    }
  }
};
Cassandra_multiget_slice_result.prototype = {};
Cassandra_multiget_slice_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.MAP) {
        var _size206 = 0;
        var _rtmp3210;
        this.success = {};
        var _ktype207 = 0;
        var _vtype208 = 0;
        _rtmp3210 = input.readMapBegin();
        _ktype207 = _rtmp3210.ktype;
        _vtype208 = _rtmp3210.vtype;
        _size206 = _rtmp3210.size;
        for (var _i211 = 0; _i211 < _size206; ++_i211)
        {
          var key212 = null;
          var val213 = null;
          key212 = input.readString();
          var _size214 = 0;
          var _rtmp3218;
          val213 = [];
          var _etype217 = 0;
          _rtmp3218 = input.readListBegin();
          _etype217 = _rtmp3218.etype;
          _size214 = _rtmp3218.size;
          for (var _i219 = 0; _i219 < _size214; ++_i219)
          {
            var elem220 = null;
            elem220 = new ttypes.ColumnOrSuperColumn();
            elem220.read(input);
            val213.push(elem220);
          }
          input.readListEnd();
          this.success[key212] = val213;
        }
        input.readMapEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException();
        this.ue.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException();
        this.te.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_multiget_slice_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_multiget_slice_result');
  if (this.success) {
    output.writeFieldBegin('success', Thrift.Type.MAP, 0);
    output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.LIST, Thrift.objectLength(this.success));
    for (var kiter221 in this.success)
    {
      if (this.success.hasOwnProperty(kiter221))
      {
        var viter222 = this.success[kiter221];
        output.writeString(kiter221);
        output.writeListBegin(Thrift.Type.STRUCT, viter222.length);
        for (var iter223 in viter222)
        {
          if (viter222.hasOwnProperty(iter223))
          {
            iter223 = viter222[iter223];
            iter223.write(output);
          }
        }
        output.writeListEnd();
      }
    }
    output.writeMapEnd();
    output.writeFieldEnd();
  }
  if (this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.ue) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2);
    this.ue.write(output);
    output.writeFieldEnd();
  }
  if (this.te) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3);
    this.te.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_multiget_count_args = function(args) {
  this.keys = null;
  this.column_parent = null;
  this.predicate = null;
  this.consistency_level = 1;
  if (args) {
    if (args.keys !== undefined) {
      this.keys = args.keys;
    }
    if (args.column_parent !== undefined) {
      this.column_parent = args.column_parent;
    }
    if (args.predicate !== undefined) {
      this.predicate = args.predicate;
    }
    if (args.consistency_level !== undefined) {
      this.consistency_level = args.consistency_level;
    }
  }
};
Cassandra_multiget_count_args.prototype = {};
Cassandra_multiget_count_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.LIST) {
        var _size224 = 0;
        var _rtmp3228;
        this.keys = [];
        var _etype227 = 0;
        _rtmp3228 = input.readListBegin();
        _etype227 = _rtmp3228.etype;
        _size224 = _rtmp3228.size;
        for (var _i229 = 0; _i229 < _size224; ++_i229)
        {
          var elem230 = null;
          elem230 = input.readString();
          this.keys.push(elem230);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.column_parent = new ttypes.ColumnParent();
        this.column_parent.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.predicate = new ttypes.SlicePredicate();
        this.predicate.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_multiget_count_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_multiget_count_args');
  if (this.keys) {
    output.writeFieldBegin('keys', Thrift.Type.LIST, 1);
    output.writeListBegin(Thrift.Type.STRING, this.keys.length);
    for (var iter231 in this.keys)
    {
      if (this.keys.hasOwnProperty(iter231))
      {
        iter231 = this.keys[iter231];
        output.writeString(iter231);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.column_parent) {
    output.writeFieldBegin('column_parent', Thrift.Type.STRUCT, 2);
    this.column_parent.write(output);
    output.writeFieldEnd();
  }
  if (this.predicate) {
    output.writeFieldBegin('predicate', Thrift.Type.STRUCT, 3);
    this.predicate.write(output);
    output.writeFieldEnd();
  }
  if (this.consistency_level) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 4);
    output.writeI32(this.consistency_level);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_multiget_count_result = function(args) {
  this.success = null;
  this.ire = null;
  this.ue = null;
  this.te = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.ue !== undefined) {
      this.ue = args.ue;
    }
    if (args.te !== undefined) {
      this.te = args.te;
    }
  }
};
Cassandra_multiget_count_result.prototype = {};
Cassandra_multiget_count_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.MAP) {
        var _size232 = 0;
        var _rtmp3236;
        this.success = {};
        var _ktype233 = 0;
        var _vtype234 = 0;
        _rtmp3236 = input.readMapBegin();
        _ktype233 = _rtmp3236.ktype;
        _vtype234 = _rtmp3236.vtype;
        _size232 = _rtmp3236.size;
        for (var _i237 = 0; _i237 < _size232; ++_i237)
        {
          var key238 = null;
          var val239 = null;
          key238 = input.readString();
          val239 = input.readI32();
          this.success[key238] = val239;
        }
        input.readMapEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException();
        this.ue.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException();
        this.te.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_multiget_count_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_multiget_count_result');
  if (this.success) {
    output.writeFieldBegin('success', Thrift.Type.MAP, 0);
    output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.I32, Thrift.objectLength(this.success));
    for (var kiter240 in this.success)
    {
      if (this.success.hasOwnProperty(kiter240))
      {
        var viter241 = this.success[kiter240];
        output.writeString(kiter240);
        output.writeI32(viter241);
      }
    }
    output.writeMapEnd();
    output.writeFieldEnd();
  }
  if (this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.ue) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2);
    this.ue.write(output);
    output.writeFieldEnd();
  }
  if (this.te) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3);
    this.te.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_get_range_slices_args = function(args) {
  this.column_parent = null;
  this.predicate = null;
  this.range = null;
  this.consistency_level = 1;
  if (args) {
    if (args.column_parent !== undefined) {
      this.column_parent = args.column_parent;
    }
    if (args.predicate !== undefined) {
      this.predicate = args.predicate;
    }
    if (args.range !== undefined) {
      this.range = args.range;
    }
    if (args.consistency_level !== undefined) {
      this.consistency_level = args.consistency_level;
    }
  }
};
Cassandra_get_range_slices_args.prototype = {};
Cassandra_get_range_slices_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.column_parent = new ttypes.ColumnParent();
        this.column_parent.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.predicate = new ttypes.SlicePredicate();
        this.predicate.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.range = new ttypes.KeyRange();
        this.range.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_get_range_slices_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_get_range_slices_args');
  if (this.column_parent) {
    output.writeFieldBegin('column_parent', Thrift.Type.STRUCT, 1);
    this.column_parent.write(output);
    output.writeFieldEnd();
  }
  if (this.predicate) {
    output.writeFieldBegin('predicate', Thrift.Type.STRUCT, 2);
    this.predicate.write(output);
    output.writeFieldEnd();
  }
  if (this.range) {
    output.writeFieldBegin('range', Thrift.Type.STRUCT, 3);
    this.range.write(output);
    output.writeFieldEnd();
  }
  if (this.consistency_level) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 4);
    output.writeI32(this.consistency_level);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_get_range_slices_result = function(args) {
  this.success = null;
  this.ire = null;
  this.ue = null;
  this.te = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.ue !== undefined) {
      this.ue = args.ue;
    }
    if (args.te !== undefined) {
      this.te = args.te;
    }
  }
};
Cassandra_get_range_slices_result.prototype = {};
Cassandra_get_range_slices_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.LIST) {
        var _size242 = 0;
        var _rtmp3246;
        this.success = [];
        var _etype245 = 0;
        _rtmp3246 = input.readListBegin();
        _etype245 = _rtmp3246.etype;
        _size242 = _rtmp3246.size;
        for (var _i247 = 0; _i247 < _size242; ++_i247)
        {
          var elem248 = null;
          elem248 = new ttypes.KeySlice();
          elem248.read(input);
          this.success.push(elem248);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException();
        this.ue.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException();
        this.te.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_get_range_slices_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_get_range_slices_result');
  if (this.success) {
    output.writeFieldBegin('success', Thrift.Type.LIST, 0);
    output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
    for (var iter249 in this.success)
    {
      if (this.success.hasOwnProperty(iter249))
      {
        iter249 = this.success[iter249];
        iter249.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.ue) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2);
    this.ue.write(output);
    output.writeFieldEnd();
  }
  if (this.te) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3);
    this.te.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_get_paged_slice_args = function(args) {
  this.column_family = null;
  this.range = null;
  this.start_column = null;
  this.consistency_level = 1;
  if (args) {
    if (args.column_family !== undefined) {
      this.column_family = args.column_family;
    }
    if (args.range !== undefined) {
      this.range = args.range;
    }
    if (args.start_column !== undefined) {
      this.start_column = args.start_column;
    }
    if (args.consistency_level !== undefined) {
      this.consistency_level = args.consistency_level;
    }
  }
};
Cassandra_get_paged_slice_args.prototype = {};
Cassandra_get_paged_slice_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.column_family = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.range = new ttypes.KeyRange();
        this.range.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRING) {
        this.start_column = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_get_paged_slice_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_get_paged_slice_args');
  if (this.column_family) {
    output.writeFieldBegin('column_family', Thrift.Type.STRING, 1);
    output.writeString(this.column_family);
    output.writeFieldEnd();
  }
  if (this.range) {
    output.writeFieldBegin('range', Thrift.Type.STRUCT, 2);
    this.range.write(output);
    output.writeFieldEnd();
  }
  if (this.start_column) {
    output.writeFieldBegin('start_column', Thrift.Type.STRING, 3);
    output.writeString(this.start_column);
    output.writeFieldEnd();
  }
  if (this.consistency_level) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 4);
    output.writeI32(this.consistency_level);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_get_paged_slice_result = function(args) {
  this.success = null;
  this.ire = null;
  this.ue = null;
  this.te = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.ue !== undefined) {
      this.ue = args.ue;
    }
    if (args.te !== undefined) {
      this.te = args.te;
    }
  }
};
Cassandra_get_paged_slice_result.prototype = {};
Cassandra_get_paged_slice_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.LIST) {
        var _size250 = 0;
        var _rtmp3254;
        this.success = [];
        var _etype253 = 0;
        _rtmp3254 = input.readListBegin();
        _etype253 = _rtmp3254.etype;
        _size250 = _rtmp3254.size;
        for (var _i255 = 0; _i255 < _size250; ++_i255)
        {
          var elem256 = null;
          elem256 = new ttypes.KeySlice();
          elem256.read(input);
          this.success.push(elem256);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException();
        this.ue.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException();
        this.te.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_get_paged_slice_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_get_paged_slice_result');
  if (this.success) {
    output.writeFieldBegin('success', Thrift.Type.LIST, 0);
    output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
    for (var iter257 in this.success)
    {
      if (this.success.hasOwnProperty(iter257))
      {
        iter257 = this.success[iter257];
        iter257.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.ue) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2);
    this.ue.write(output);
    output.writeFieldEnd();
  }
  if (this.te) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3);
    this.te.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_get_indexed_slices_args = function(args) {
  this.column_parent = null;
  this.index_clause = null;
  this.column_predicate = null;
  this.consistency_level = 1;
  if (args) {
    if (args.column_parent !== undefined) {
      this.column_parent = args.column_parent;
    }
    if (args.index_clause !== undefined) {
      this.index_clause = args.index_clause;
    }
    if (args.column_predicate !== undefined) {
      this.column_predicate = args.column_predicate;
    }
    if (args.consistency_level !== undefined) {
      this.consistency_level = args.consistency_level;
    }
  }
};
Cassandra_get_indexed_slices_args.prototype = {};
Cassandra_get_indexed_slices_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.column_parent = new ttypes.ColumnParent();
        this.column_parent.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.index_clause = new ttypes.IndexClause();
        this.index_clause.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.column_predicate = new ttypes.SlicePredicate();
        this.column_predicate.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_get_indexed_slices_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_get_indexed_slices_args');
  if (this.column_parent) {
    output.writeFieldBegin('column_parent', Thrift.Type.STRUCT, 1);
    this.column_parent.write(output);
    output.writeFieldEnd();
  }
  if (this.index_clause) {
    output.writeFieldBegin('index_clause', Thrift.Type.STRUCT, 2);
    this.index_clause.write(output);
    output.writeFieldEnd();
  }
  if (this.column_predicate) {
    output.writeFieldBegin('column_predicate', Thrift.Type.STRUCT, 3);
    this.column_predicate.write(output);
    output.writeFieldEnd();
  }
  if (this.consistency_level) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 4);
    output.writeI32(this.consistency_level);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_get_indexed_slices_result = function(args) {
  this.success = null;
  this.ire = null;
  this.ue = null;
  this.te = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.ue !== undefined) {
      this.ue = args.ue;
    }
    if (args.te !== undefined) {
      this.te = args.te;
    }
  }
};
Cassandra_get_indexed_slices_result.prototype = {};
Cassandra_get_indexed_slices_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.LIST) {
        var _size258 = 0;
        var _rtmp3262;
        this.success = [];
        var _etype261 = 0;
        _rtmp3262 = input.readListBegin();
        _etype261 = _rtmp3262.etype;
        _size258 = _rtmp3262.size;
        for (var _i263 = 0; _i263 < _size258; ++_i263)
        {
          var elem264 = null;
          elem264 = new ttypes.KeySlice();
          elem264.read(input);
          this.success.push(elem264);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException();
        this.ue.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException();
        this.te.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_get_indexed_slices_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_get_indexed_slices_result');
  if (this.success) {
    output.writeFieldBegin('success', Thrift.Type.LIST, 0);
    output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
    for (var iter265 in this.success)
    {
      if (this.success.hasOwnProperty(iter265))
      {
        iter265 = this.success[iter265];
        iter265.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.ue) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2);
    this.ue.write(output);
    output.writeFieldEnd();
  }
  if (this.te) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3);
    this.te.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_insert_args = function(args) {
  this.key = null;
  this.column_parent = null;
  this.column = null;
  this.consistency_level = 1;
  if (args) {
    if (args.key !== undefined) {
      this.key = args.key;
    }
    if (args.column_parent !== undefined) {
      this.column_parent = args.column_parent;
    }
    if (args.column !== undefined) {
      this.column = args.column;
    }
    if (args.consistency_level !== undefined) {
      this.consistency_level = args.consistency_level;
    }
  }
};
Cassandra_insert_args.prototype = {};
Cassandra_insert_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.key = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.column_parent = new ttypes.ColumnParent();
        this.column_parent.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.column = new ttypes.Column();
        this.column.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_insert_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_insert_args');
  if (this.key) {
    output.writeFieldBegin('key', Thrift.Type.STRING, 1);
    output.writeString(this.key);
    output.writeFieldEnd();
  }
  if (this.column_parent) {
    output.writeFieldBegin('column_parent', Thrift.Type.STRUCT, 2);
    this.column_parent.write(output);
    output.writeFieldEnd();
  }
  if (this.column) {
    output.writeFieldBegin('column', Thrift.Type.STRUCT, 3);
    this.column.write(output);
    output.writeFieldEnd();
  }
  if (this.consistency_level) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 4);
    output.writeI32(this.consistency_level);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_insert_result = function(args) {
  this.ire = null;
  this.ue = null;
  this.te = null;
  if (args) {
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.ue !== undefined) {
      this.ue = args.ue;
    }
    if (args.te !== undefined) {
      this.te = args.te;
    }
  }
};
Cassandra_insert_result.prototype = {};
Cassandra_insert_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException();
        this.ue.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException();
        this.te.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_insert_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_insert_result');
  if (this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.ue) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2);
    this.ue.write(output);
    output.writeFieldEnd();
  }
  if (this.te) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3);
    this.te.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_add_args = function(args) {
  this.key = null;
  this.column_parent = null;
  this.column = null;
  this.consistency_level = 1;
  if (args) {
    if (args.key !== undefined) {
      this.key = args.key;
    }
    if (args.column_parent !== undefined) {
      this.column_parent = args.column_parent;
    }
    if (args.column !== undefined) {
      this.column = args.column;
    }
    if (args.consistency_level !== undefined) {
      this.consistency_level = args.consistency_level;
    }
  }
};
Cassandra_add_args.prototype = {};
Cassandra_add_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.key = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.column_parent = new ttypes.ColumnParent();
        this.column_parent.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.column = new ttypes.CounterColumn();
        this.column.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_add_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_add_args');
  if (this.key) {
    output.writeFieldBegin('key', Thrift.Type.STRING, 1);
    output.writeString(this.key);
    output.writeFieldEnd();
  }
  if (this.column_parent) {
    output.writeFieldBegin('column_parent', Thrift.Type.STRUCT, 2);
    this.column_parent.write(output);
    output.writeFieldEnd();
  }
  if (this.column) {
    output.writeFieldBegin('column', Thrift.Type.STRUCT, 3);
    this.column.write(output);
    output.writeFieldEnd();
  }
  if (this.consistency_level) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 4);
    output.writeI32(this.consistency_level);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_add_result = function(args) {
  this.ire = null;
  this.ue = null;
  this.te = null;
  if (args) {
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.ue !== undefined) {
      this.ue = args.ue;
    }
    if (args.te !== undefined) {
      this.te = args.te;
    }
  }
};
Cassandra_add_result.prototype = {};
Cassandra_add_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException();
        this.ue.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException();
        this.te.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_add_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_add_result');
  if (this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.ue) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2);
    this.ue.write(output);
    output.writeFieldEnd();
  }
  if (this.te) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3);
    this.te.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_remove_args = function(args) {
  this.key = null;
  this.column_path = null;
  this.timestamp = null;
  this.consistency_level = 1;
  if (args) {
    if (args.key !== undefined) {
      this.key = args.key;
    }
    if (args.column_path !== undefined) {
      this.column_path = args.column_path;
    }
    if (args.timestamp !== undefined) {
      this.timestamp = args.timestamp;
    }
    if (args.consistency_level !== undefined) {
      this.consistency_level = args.consistency_level;
    }
  }
};
Cassandra_remove_args.prototype = {};
Cassandra_remove_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.key = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.column_path = new ttypes.ColumnPath();
        this.column_path.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.I64) {
        this.timestamp = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_remove_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_remove_args');
  if (this.key) {
    output.writeFieldBegin('key', Thrift.Type.STRING, 1);
    output.writeString(this.key);
    output.writeFieldEnd();
  }
  if (this.column_path) {
    output.writeFieldBegin('column_path', Thrift.Type.STRUCT, 2);
    this.column_path.write(output);
    output.writeFieldEnd();
  }
  if (this.timestamp) {
    output.writeFieldBegin('timestamp', Thrift.Type.I64, 3);
    output.writeI64(this.timestamp);
    output.writeFieldEnd();
  }
  if (this.consistency_level) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 4);
    output.writeI32(this.consistency_level);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_remove_result = function(args) {
  this.ire = null;
  this.ue = null;
  this.te = null;
  if (args) {
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.ue !== undefined) {
      this.ue = args.ue;
    }
    if (args.te !== undefined) {
      this.te = args.te;
    }
  }
};
Cassandra_remove_result.prototype = {};
Cassandra_remove_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException();
        this.ue.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException();
        this.te.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_remove_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_remove_result');
  if (this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.ue) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2);
    this.ue.write(output);
    output.writeFieldEnd();
  }
  if (this.te) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3);
    this.te.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_remove_counter_args = function(args) {
  this.key = null;
  this.path = null;
  this.consistency_level = 1;
  if (args) {
    if (args.key !== undefined) {
      this.key = args.key;
    }
    if (args.path !== undefined) {
      this.path = args.path;
    }
    if (args.consistency_level !== undefined) {
      this.consistency_level = args.consistency_level;
    }
  }
};
Cassandra_remove_counter_args.prototype = {};
Cassandra_remove_counter_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.key = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.path = new ttypes.ColumnPath();
        this.path.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_remove_counter_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_remove_counter_args');
  if (this.key) {
    output.writeFieldBegin('key', Thrift.Type.STRING, 1);
    output.writeString(this.key);
    output.writeFieldEnd();
  }
  if (this.path) {
    output.writeFieldBegin('path', Thrift.Type.STRUCT, 2);
    this.path.write(output);
    output.writeFieldEnd();
  }
  if (this.consistency_level) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 3);
    output.writeI32(this.consistency_level);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_remove_counter_result = function(args) {
  this.ire = null;
  this.ue = null;
  this.te = null;
  if (args) {
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.ue !== undefined) {
      this.ue = args.ue;
    }
    if (args.te !== undefined) {
      this.te = args.te;
    }
  }
};
Cassandra_remove_counter_result.prototype = {};
Cassandra_remove_counter_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException();
        this.ue.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException();
        this.te.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_remove_counter_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_remove_counter_result');
  if (this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.ue) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2);
    this.ue.write(output);
    output.writeFieldEnd();
  }
  if (this.te) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3);
    this.te.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_batch_mutate_args = function(args) {
  this.mutation_map = null;
  this.consistency_level = 1;
  if (args) {
    if (args.mutation_map !== undefined) {
      this.mutation_map = args.mutation_map;
    }
    if (args.consistency_level !== undefined) {
      this.consistency_level = args.consistency_level;
    }
  }
};
Cassandra_batch_mutate_args.prototype = {};
Cassandra_batch_mutate_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.MAP) {
        var _size266 = 0;
        var _rtmp3270;
        this.mutation_map = {};
        var _ktype267 = 0;
        var _vtype268 = 0;
        _rtmp3270 = input.readMapBegin();
        _ktype267 = _rtmp3270.ktype;
        _vtype268 = _rtmp3270.vtype;
        _size266 = _rtmp3270.size;
        for (var _i271 = 0; _i271 < _size266; ++_i271)
        {
          var key272 = null;
          var val273 = null;
          key272 = input.readString();
          var _size274 = 0;
          var _rtmp3278;
          val273 = {};
          var _ktype275 = 0;
          var _vtype276 = 0;
          _rtmp3278 = input.readMapBegin();
          _ktype275 = _rtmp3278.ktype;
          _vtype276 = _rtmp3278.vtype;
          _size274 = _rtmp3278.size;
          for (var _i279 = 0; _i279 < _size274; ++_i279)
          {
            var key280 = null;
            var val281 = null;
            key280 = input.readString();
            var _size282 = 0;
            var _rtmp3286;
            val281 = [];
            var _etype285 = 0;
            _rtmp3286 = input.readListBegin();
            _etype285 = _rtmp3286.etype;
            _size282 = _rtmp3286.size;
            for (var _i287 = 0; _i287 < _size282; ++_i287)
            {
              var elem288 = null;
              elem288 = new ttypes.Mutation();
              elem288.read(input);
              val281.push(elem288);
            }
            input.readListEnd();
            val273[key280] = val281;
          }
          input.readMapEnd();
          this.mutation_map[key272] = val273;
        }
        input.readMapEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_batch_mutate_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_batch_mutate_args');
  if (this.mutation_map) {
    output.writeFieldBegin('mutation_map', Thrift.Type.MAP, 1);
    output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.MAP, Thrift.objectLength(this.mutation_map));
    for (var kiter289 in this.mutation_map)
    {
      if (this.mutation_map.hasOwnProperty(kiter289))
      {
        var viter290 = this.mutation_map[kiter289];
        output.writeString(new Buffer(kiter289, 'binary'));
        output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.LIST, Thrift.objectLength(viter290));
        for (var kiter291 in viter290)
        {
          if (viter290.hasOwnProperty(kiter291))
          {
            var viter292 = viter290[kiter291];
            output.writeString(kiter291);
            output.writeListBegin(Thrift.Type.STRUCT, viter292.length);
            for (var iter293 in viter292)
            {
              if (viter292.hasOwnProperty(iter293))
              {
                iter293 = viter292[iter293];
                iter293.write(output);
              }
            }
            output.writeListEnd();
          }
        }
        output.writeMapEnd();
      }
    }
    output.writeMapEnd();
    output.writeFieldEnd();
  }
  if (this.consistency_level) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 2);
    output.writeI32(this.consistency_level);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_batch_mutate_result = function(args) {
  this.ire = null;
  this.ue = null;
  this.te = null;
  if (args) {
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.ue !== undefined) {
      this.ue = args.ue;
    }
    if (args.te !== undefined) {
      this.te = args.te;
    }
  }
};
Cassandra_batch_mutate_result.prototype = {};
Cassandra_batch_mutate_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException();
        this.ue.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException();
        this.te.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_batch_mutate_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_batch_mutate_result');
  if (this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.ue) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2);
    this.ue.write(output);
    output.writeFieldEnd();
  }
  if (this.te) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3);
    this.te.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_atomic_batch_mutate_args = function(args) {
  this.mutation_map = null;
  this.consistency_level = 1;
  if (args) {
    if (args.mutation_map !== undefined) {
      this.mutation_map = args.mutation_map;
    }
    if (args.consistency_level !== undefined) {
      this.consistency_level = args.consistency_level;
    }
  }
};
Cassandra_atomic_batch_mutate_args.prototype = {};
Cassandra_atomic_batch_mutate_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.MAP) {
        var _size294 = 0;
        var _rtmp3298;
        this.mutation_map = {};
        var _ktype295 = 0;
        var _vtype296 = 0;
        _rtmp3298 = input.readMapBegin();
        _ktype295 = _rtmp3298.ktype;
        _vtype296 = _rtmp3298.vtype;
        _size294 = _rtmp3298.size;
        for (var _i299 = 0; _i299 < _size294; ++_i299)
        {
          var key300 = null;
          var val301 = null;
          key300 = input.readString();
          var _size302 = 0;
          var _rtmp3306;
          val301 = {};
          var _ktype303 = 0;
          var _vtype304 = 0;
          _rtmp3306 = input.readMapBegin();
          _ktype303 = _rtmp3306.ktype;
          _vtype304 = _rtmp3306.vtype;
          _size302 = _rtmp3306.size;
          for (var _i307 = 0; _i307 < _size302; ++_i307)
          {
            var key308 = null;
            var val309 = null;
            key308 = input.readString();
            var _size310 = 0;
            var _rtmp3314;
            val309 = [];
            var _etype313 = 0;
            _rtmp3314 = input.readListBegin();
            _etype313 = _rtmp3314.etype;
            _size310 = _rtmp3314.size;
            for (var _i315 = 0; _i315 < _size310; ++_i315)
            {
              var elem316 = null;
              elem316 = new ttypes.Mutation();
              elem316.read(input);
              val309.push(elem316);
            }
            input.readListEnd();
            val301[key308] = val309;
          }
          input.readMapEnd();
          this.mutation_map[key300] = val301;
        }
        input.readMapEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I32) {
        this.consistency_level = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_atomic_batch_mutate_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_atomic_batch_mutate_args');
  if (this.mutation_map) {
    output.writeFieldBegin('mutation_map', Thrift.Type.MAP, 1);
    output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.MAP, Thrift.objectLength(this.mutation_map));
    for (var kiter317 in this.mutation_map)
    {
      if (this.mutation_map.hasOwnProperty(kiter317))
      {
        var viter318 = this.mutation_map[kiter317];
        output.writeString(kiter317);
        output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.LIST, Thrift.objectLength(viter318));
        for (var kiter319 in viter318)
        {
          if (viter318.hasOwnProperty(kiter319))
          {
            var viter320 = viter318[kiter319];
            output.writeString(kiter319);
            output.writeListBegin(Thrift.Type.STRUCT, viter320.length);
            for (var iter321 in viter320)
            {
              if (viter320.hasOwnProperty(iter321))
              {
                iter321 = viter320[iter321];
                iter321.write(output);
              }
            }
            output.writeListEnd();
          }
        }
        output.writeMapEnd();
      }
    }
    output.writeMapEnd();
    output.writeFieldEnd();
  }
  if (this.consistency_level) {
    output.writeFieldBegin('consistency_level', Thrift.Type.I32, 2);
    output.writeI32(this.consistency_level);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_atomic_batch_mutate_result = function(args) {
  this.ire = null;
  this.ue = null;
  this.te = null;
  if (args) {
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.ue !== undefined) {
      this.ue = args.ue;
    }
    if (args.te !== undefined) {
      this.te = args.te;
    }
  }
};
Cassandra_atomic_batch_mutate_result.prototype = {};
Cassandra_atomic_batch_mutate_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException();
        this.ue.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException();
        this.te.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_atomic_batch_mutate_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_atomic_batch_mutate_result');
  if (this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.ue) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2);
    this.ue.write(output);
    output.writeFieldEnd();
  }
  if (this.te) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3);
    this.te.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_truncate_args = function(args) {
  this.cfname = null;
  if (args) {
    if (args.cfname !== undefined) {
      this.cfname = args.cfname;
    }
  }
};
Cassandra_truncate_args.prototype = {};
Cassandra_truncate_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.cfname = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_truncate_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_truncate_args');
  if (this.cfname) {
    output.writeFieldBegin('cfname', Thrift.Type.STRING, 1);
    output.writeString(this.cfname);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_truncate_result = function(args) {
  this.ire = null;
  this.ue = null;
  this.te = null;
  if (args) {
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.ue !== undefined) {
      this.ue = args.ue;
    }
    if (args.te !== undefined) {
      this.te = args.te;
    }
  }
};
Cassandra_truncate_result.prototype = {};
Cassandra_truncate_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException();
        this.ue.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException();
        this.te.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_truncate_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_truncate_result');
  if (this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.ue) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2);
    this.ue.write(output);
    output.writeFieldEnd();
  }
  if (this.te) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3);
    this.te.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_describe_schema_versions_args = function(args) {
};
Cassandra_describe_schema_versions_args.prototype = {};
Cassandra_describe_schema_versions_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_describe_schema_versions_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_describe_schema_versions_args');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_describe_schema_versions_result = function(args) {
  this.success = null;
  this.ire = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
  }
};
Cassandra_describe_schema_versions_result.prototype = {};
Cassandra_describe_schema_versions_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.MAP) {
        var _size322 = 0;
        var _rtmp3326;
        this.success = {};
        var _ktype323 = 0;
        var _vtype324 = 0;
        _rtmp3326 = input.readMapBegin();
        _ktype323 = _rtmp3326.ktype;
        _vtype324 = _rtmp3326.vtype;
        _size322 = _rtmp3326.size;
        for (var _i327 = 0; _i327 < _size322; ++_i327)
        {
          var key328 = null;
          var val329 = null;
          key328 = input.readString();
          var _size330 = 0;
          var _rtmp3334;
          val329 = [];
          var _etype333 = 0;
          _rtmp3334 = input.readListBegin();
          _etype333 = _rtmp3334.etype;
          _size330 = _rtmp3334.size;
          for (var _i335 = 0; _i335 < _size330; ++_i335)
          {
            var elem336 = null;
            elem336 = input.readString();
            val329.push(elem336);
          }
          input.readListEnd();
          this.success[key328] = val329;
        }
        input.readMapEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_describe_schema_versions_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_describe_schema_versions_result');
  if (this.success) {
    output.writeFieldBegin('success', Thrift.Type.MAP, 0);
    output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.LIST, Thrift.objectLength(this.success));
    for (var kiter337 in this.success)
    {
      if (this.success.hasOwnProperty(kiter337))
      {
        var viter338 = this.success[kiter337];
        output.writeString(kiter337);
        output.writeListBegin(Thrift.Type.STRING, viter338.length);
        for (var iter339 in viter338)
        {
          if (viter338.hasOwnProperty(iter339))
          {
            iter339 = viter338[iter339];
            output.writeString(iter339);
          }
        }
        output.writeListEnd();
      }
    }
    output.writeMapEnd();
    output.writeFieldEnd();
  }
  if (this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_describe_keyspaces_args = function(args) {
};
Cassandra_describe_keyspaces_args.prototype = {};
Cassandra_describe_keyspaces_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_describe_keyspaces_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_describe_keyspaces_args');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_describe_keyspaces_result = function(args) {
  this.success = null;
  this.ire = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
  }
};
Cassandra_describe_keyspaces_result.prototype = {};
Cassandra_describe_keyspaces_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.LIST) {
        var _size340 = 0;
        var _rtmp3344;
        this.success = [];
        var _etype343 = 0;
        _rtmp3344 = input.readListBegin();
        _etype343 = _rtmp3344.etype;
        _size340 = _rtmp3344.size;
        for (var _i345 = 0; _i345 < _size340; ++_i345)
        {
          var elem346 = null;
          elem346 = new ttypes.KsDef();
          elem346.read(input);
          this.success.push(elem346);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_describe_keyspaces_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_describe_keyspaces_result');
  if (this.success) {
    output.writeFieldBegin('success', Thrift.Type.LIST, 0);
    output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
    for (var iter347 in this.success)
    {
      if (this.success.hasOwnProperty(iter347))
      {
        iter347 = this.success[iter347];
        iter347.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_describe_cluster_name_args = function(args) {
};
Cassandra_describe_cluster_name_args.prototype = {};
Cassandra_describe_cluster_name_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_describe_cluster_name_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_describe_cluster_name_args');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_describe_cluster_name_result = function(args) {
  this.success = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
  }
};
Cassandra_describe_cluster_name_result.prototype = {};
Cassandra_describe_cluster_name_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.STRING) {
        this.success = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_describe_cluster_name_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_describe_cluster_name_result');
  if (this.success) {
    output.writeFieldBegin('success', Thrift.Type.STRING, 0);
    output.writeString(this.success);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_describe_version_args = function(args) {
};
Cassandra_describe_version_args.prototype = {};
Cassandra_describe_version_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_describe_version_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_describe_version_args');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_describe_version_result = function(args) {
  this.success = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
  }
};
Cassandra_describe_version_result.prototype = {};
Cassandra_describe_version_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.STRING) {
        this.success = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_describe_version_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_describe_version_result');
  if (this.success) {
    output.writeFieldBegin('success', Thrift.Type.STRING, 0);
    output.writeString(this.success);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_describe_ring_args = function(args) {
  this.keyspace = null;
  if (args) {
    if (args.keyspace !== undefined) {
      this.keyspace = args.keyspace;
    }
  }
};
Cassandra_describe_ring_args.prototype = {};
Cassandra_describe_ring_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.keyspace = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_describe_ring_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_describe_ring_args');
  if (this.keyspace) {
    output.writeFieldBegin('keyspace', Thrift.Type.STRING, 1);
    output.writeString(this.keyspace);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_describe_ring_result = function(args) {
  this.success = null;
  this.ire = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
  }
};
Cassandra_describe_ring_result.prototype = {};
Cassandra_describe_ring_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.LIST) {
        var _size348 = 0;
        var _rtmp3352;
        this.success = [];
        var _etype351 = 0;
        _rtmp3352 = input.readListBegin();
        _etype351 = _rtmp3352.etype;
        _size348 = _rtmp3352.size;
        for (var _i353 = 0; _i353 < _size348; ++_i353)
        {
          var elem354 = null;
          elem354 = new ttypes.TokenRange();
          elem354.read(input);
          this.success.push(elem354);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_describe_ring_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_describe_ring_result');
  if (this.success) {
    output.writeFieldBegin('success', Thrift.Type.LIST, 0);
    output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
    for (var iter355 in this.success)
    {
      if (this.success.hasOwnProperty(iter355))
      {
        iter355 = this.success[iter355];
        iter355.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_describe_token_map_args = function(args) {
};
Cassandra_describe_token_map_args.prototype = {};
Cassandra_describe_token_map_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_describe_token_map_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_describe_token_map_args');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_describe_token_map_result = function(args) {
  this.success = null;
  this.ire = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
  }
};
Cassandra_describe_token_map_result.prototype = {};
Cassandra_describe_token_map_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.MAP) {
        var _size356 = 0;
        var _rtmp3360;
        this.success = {};
        var _ktype357 = 0;
        var _vtype358 = 0;
        _rtmp3360 = input.readMapBegin();
        _ktype357 = _rtmp3360.ktype;
        _vtype358 = _rtmp3360.vtype;
        _size356 = _rtmp3360.size;
        for (var _i361 = 0; _i361 < _size356; ++_i361)
        {
          var key362 = null;
          var val363 = null;
          key362 = input.readString();
          val363 = input.readString();
          this.success[key362] = val363;
        }
        input.readMapEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_describe_token_map_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_describe_token_map_result');
  if (this.success) {
    output.writeFieldBegin('success', Thrift.Type.MAP, 0);
    output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRING, Thrift.objectLength(this.success));
    for (var kiter364 in this.success)
    {
      if (this.success.hasOwnProperty(kiter364))
      {
        var viter365 = this.success[kiter364];
        output.writeString(kiter364);
        output.writeString(viter365);
      }
    }
    output.writeMapEnd();
    output.writeFieldEnd();
  }
  if (this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_describe_partitioner_args = function(args) {
};
Cassandra_describe_partitioner_args.prototype = {};
Cassandra_describe_partitioner_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_describe_partitioner_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_describe_partitioner_args');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_describe_partitioner_result = function(args) {
  this.success = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
  }
};
Cassandra_describe_partitioner_result.prototype = {};
Cassandra_describe_partitioner_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.STRING) {
        this.success = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_describe_partitioner_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_describe_partitioner_result');
  if (this.success) {
    output.writeFieldBegin('success', Thrift.Type.STRING, 0);
    output.writeString(this.success);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_describe_snitch_args = function(args) {
};
Cassandra_describe_snitch_args.prototype = {};
Cassandra_describe_snitch_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_describe_snitch_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_describe_snitch_args');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_describe_snitch_result = function(args) {
  this.success = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
  }
};
Cassandra_describe_snitch_result.prototype = {};
Cassandra_describe_snitch_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.STRING) {
        this.success = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_describe_snitch_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_describe_snitch_result');
  if (this.success) {
    output.writeFieldBegin('success', Thrift.Type.STRING, 0);
    output.writeString(this.success);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_describe_keyspace_args = function(args) {
  this.keyspace = null;
  if (args) {
    if (args.keyspace !== undefined) {
      this.keyspace = args.keyspace;
    }
  }
};
Cassandra_describe_keyspace_args.prototype = {};
Cassandra_describe_keyspace_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.keyspace = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_describe_keyspace_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_describe_keyspace_args');
  if (this.keyspace) {
    output.writeFieldBegin('keyspace', Thrift.Type.STRING, 1);
    output.writeString(this.keyspace);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_describe_keyspace_result = function(args) {
  this.success = null;
  this.nfe = null;
  this.ire = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.nfe !== undefined) {
      this.nfe = args.nfe;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
  }
};
Cassandra_describe_keyspace_result.prototype = {};
Cassandra_describe_keyspace_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.STRUCT) {
        this.success = new ttypes.KsDef();
        this.success.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.nfe = new ttypes.NotFoundException();
        this.nfe.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_describe_keyspace_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_describe_keyspace_result');
  if (this.success) {
    output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
    this.success.write(output);
    output.writeFieldEnd();
  }
  if (this.nfe) {
    output.writeFieldBegin('nfe', Thrift.Type.STRUCT, 1);
    this.nfe.write(output);
    output.writeFieldEnd();
  }
  if (this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 2);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_describe_splits_args = function(args) {
  this.cfName = null;
  this.start_token = null;
  this.end_token = null;
  this.keys_per_split = null;
  if (args) {
    if (args.cfName !== undefined) {
      this.cfName = args.cfName;
    }
    if (args.start_token !== undefined) {
      this.start_token = args.start_token;
    }
    if (args.end_token !== undefined) {
      this.end_token = args.end_token;
    }
    if (args.keys_per_split !== undefined) {
      this.keys_per_split = args.keys_per_split;
    }
  }
};
Cassandra_describe_splits_args.prototype = {};
Cassandra_describe_splits_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.cfName = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.start_token = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRING) {
        this.end_token = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.I32) {
        this.keys_per_split = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_describe_splits_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_describe_splits_args');
  if (this.cfName) {
    output.writeFieldBegin('cfName', Thrift.Type.STRING, 1);
    output.writeString(this.cfName);
    output.writeFieldEnd();
  }
  if (this.start_token) {
    output.writeFieldBegin('start_token', Thrift.Type.STRING, 2);
    output.writeString(this.start_token);
    output.writeFieldEnd();
  }
  if (this.end_token) {
    output.writeFieldBegin('end_token', Thrift.Type.STRING, 3);
    output.writeString(this.end_token);
    output.writeFieldEnd();
  }
  if (this.keys_per_split) {
    output.writeFieldBegin('keys_per_split', Thrift.Type.I32, 4);
    output.writeI32(this.keys_per_split);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_describe_splits_result = function(args) {
  this.success = null;
  this.ire = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
  }
};
Cassandra_describe_splits_result.prototype = {};
Cassandra_describe_splits_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.LIST) {
        var _size366 = 0;
        var _rtmp3370;
        this.success = [];
        var _etype369 = 0;
        _rtmp3370 = input.readListBegin();
        _etype369 = _rtmp3370.etype;
        _size366 = _rtmp3370.size;
        for (var _i371 = 0; _i371 < _size366; ++_i371)
        {
          var elem372 = null;
          elem372 = input.readString();
          this.success.push(elem372);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_describe_splits_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_describe_splits_result');
  if (this.success) {
    output.writeFieldBegin('success', Thrift.Type.LIST, 0);
    output.writeListBegin(Thrift.Type.STRING, this.success.length);
    for (var iter373 in this.success)
    {
      if (this.success.hasOwnProperty(iter373))
      {
        iter373 = this.success[iter373];
        output.writeString(iter373);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_trace_next_query_args = function(args) {
};
Cassandra_trace_next_query_args.prototype = {};
Cassandra_trace_next_query_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    input.skip(ftype);
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_trace_next_query_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_trace_next_query_args');
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_trace_next_query_result = function(args) {
  this.success = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
  }
};
Cassandra_trace_next_query_result.prototype = {};
Cassandra_trace_next_query_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.STRING) {
        this.success = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_trace_next_query_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_trace_next_query_result');
  if (this.success) {
    output.writeFieldBegin('success', Thrift.Type.STRING, 0);
    output.writeString(this.success);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_describe_splits_ex_args = function(args) {
  this.cfName = null;
  this.start_token = null;
  this.end_token = null;
  this.keys_per_split = null;
  if (args) {
    if (args.cfName !== undefined) {
      this.cfName = args.cfName;
    }
    if (args.start_token !== undefined) {
      this.start_token = args.start_token;
    }
    if (args.end_token !== undefined) {
      this.end_token = args.end_token;
    }
    if (args.keys_per_split !== undefined) {
      this.keys_per_split = args.keys_per_split;
    }
  }
};
Cassandra_describe_splits_ex_args.prototype = {};
Cassandra_describe_splits_ex_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.cfName = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.start_token = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRING) {
        this.end_token = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.I32) {
        this.keys_per_split = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_describe_splits_ex_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_describe_splits_ex_args');
  if (this.cfName) {
    output.writeFieldBegin('cfName', Thrift.Type.STRING, 1);
    output.writeString(this.cfName);
    output.writeFieldEnd();
  }
  if (this.start_token) {
    output.writeFieldBegin('start_token', Thrift.Type.STRING, 2);
    output.writeString(this.start_token);
    output.writeFieldEnd();
  }
  if (this.end_token) {
    output.writeFieldBegin('end_token', Thrift.Type.STRING, 3);
    output.writeString(this.end_token);
    output.writeFieldEnd();
  }
  if (this.keys_per_split) {
    output.writeFieldBegin('keys_per_split', Thrift.Type.I32, 4);
    output.writeI32(this.keys_per_split);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_describe_splits_ex_result = function(args) {
  this.success = null;
  this.ire = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
  }
};
Cassandra_describe_splits_ex_result.prototype = {};
Cassandra_describe_splits_ex_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.LIST) {
        var _size374 = 0;
        var _rtmp3378;
        this.success = [];
        var _etype377 = 0;
        _rtmp3378 = input.readListBegin();
        _etype377 = _rtmp3378.etype;
        _size374 = _rtmp3378.size;
        for (var _i379 = 0; _i379 < _size374; ++_i379)
        {
          var elem380 = null;
          elem380 = new ttypes.CfSplit();
          elem380.read(input);
          this.success.push(elem380);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_describe_splits_ex_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_describe_splits_ex_result');
  if (this.success) {
    output.writeFieldBegin('success', Thrift.Type.LIST, 0);
    output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
    for (var iter381 in this.success)
    {
      if (this.success.hasOwnProperty(iter381))
      {
        iter381 = this.success[iter381];
        iter381.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_system_add_column_family_args = function(args) {
  this.cf_def = null;
  if (args) {
    if (args.cf_def !== undefined) {
      this.cf_def = args.cf_def;
    }
  }
};
Cassandra_system_add_column_family_args.prototype = {};
Cassandra_system_add_column_family_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.cf_def = new ttypes.CfDef();
        this.cf_def.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_system_add_column_family_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_system_add_column_family_args');
  if (this.cf_def) {
    output.writeFieldBegin('cf_def', Thrift.Type.STRUCT, 1);
    this.cf_def.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_system_add_column_family_result = function(args) {
  this.success = null;
  this.ire = null;
  this.sde = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.sde !== undefined) {
      this.sde = args.sde;
    }
  }
};
Cassandra_system_add_column_family_result.prototype = {};
Cassandra_system_add_column_family_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.STRING) {
        this.success = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.sde = new ttypes.SchemaDisagreementException();
        this.sde.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_system_add_column_family_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_system_add_column_family_result');
  if (this.success) {
    output.writeFieldBegin('success', Thrift.Type.STRING, 0);
    output.writeString(this.success);
    output.writeFieldEnd();
  }
  if (this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.sde) {
    output.writeFieldBegin('sde', Thrift.Type.STRUCT, 2);
    this.sde.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_system_drop_column_family_args = function(args) {
  this.column_family = null;
  if (args) {
    if (args.column_family !== undefined) {
      this.column_family = args.column_family;
    }
  }
};
Cassandra_system_drop_column_family_args.prototype = {};
Cassandra_system_drop_column_family_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.column_family = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_system_drop_column_family_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_system_drop_column_family_args');
  if (this.column_family) {
    output.writeFieldBegin('column_family', Thrift.Type.STRING, 1);
    output.writeString(this.column_family);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_system_drop_column_family_result = function(args) {
  this.success = null;
  this.ire = null;
  this.sde = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.sde !== undefined) {
      this.sde = args.sde;
    }
  }
};
Cassandra_system_drop_column_family_result.prototype = {};
Cassandra_system_drop_column_family_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.STRING) {
        this.success = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.sde = new ttypes.SchemaDisagreementException();
        this.sde.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_system_drop_column_family_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_system_drop_column_family_result');
  if (this.success) {
    output.writeFieldBegin('success', Thrift.Type.STRING, 0);
    output.writeString(this.success);
    output.writeFieldEnd();
  }
  if (this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.sde) {
    output.writeFieldBegin('sde', Thrift.Type.STRUCT, 2);
    this.sde.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_system_add_keyspace_args = function(args) {
  this.ks_def = null;
  if (args) {
    if (args.ks_def !== undefined) {
      this.ks_def = args.ks_def;
    }
  }
};
Cassandra_system_add_keyspace_args.prototype = {};
Cassandra_system_add_keyspace_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ks_def = new ttypes.KsDef();
        this.ks_def.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_system_add_keyspace_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_system_add_keyspace_args');
  if (this.ks_def) {
    output.writeFieldBegin('ks_def', Thrift.Type.STRUCT, 1);
    this.ks_def.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_system_add_keyspace_result = function(args) {
  this.success = null;
  this.ire = null;
  this.sde = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.sde !== undefined) {
      this.sde = args.sde;
    }
  }
};
Cassandra_system_add_keyspace_result.prototype = {};
Cassandra_system_add_keyspace_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.STRING) {
        this.success = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.sde = new ttypes.SchemaDisagreementException();
        this.sde.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_system_add_keyspace_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_system_add_keyspace_result');
  if (this.success) {
    output.writeFieldBegin('success', Thrift.Type.STRING, 0);
    output.writeString(this.success);
    output.writeFieldEnd();
  }
  if (this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.sde) {
    output.writeFieldBegin('sde', Thrift.Type.STRUCT, 2);
    this.sde.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_system_drop_keyspace_args = function(args) {
  this.keyspace = null;
  if (args) {
    if (args.keyspace !== undefined) {
      this.keyspace = args.keyspace;
    }
  }
};
Cassandra_system_drop_keyspace_args.prototype = {};
Cassandra_system_drop_keyspace_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.keyspace = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_system_drop_keyspace_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_system_drop_keyspace_args');
  if (this.keyspace) {
    output.writeFieldBegin('keyspace', Thrift.Type.STRING, 1);
    output.writeString(this.keyspace);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_system_drop_keyspace_result = function(args) {
  this.success = null;
  this.ire = null;
  this.sde = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.sde !== undefined) {
      this.sde = args.sde;
    }
  }
};
Cassandra_system_drop_keyspace_result.prototype = {};
Cassandra_system_drop_keyspace_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.STRING) {
        this.success = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.sde = new ttypes.SchemaDisagreementException();
        this.sde.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_system_drop_keyspace_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_system_drop_keyspace_result');
  if (this.success) {
    output.writeFieldBegin('success', Thrift.Type.STRING, 0);
    output.writeString(this.success);
    output.writeFieldEnd();
  }
  if (this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.sde) {
    output.writeFieldBegin('sde', Thrift.Type.STRUCT, 2);
    this.sde.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_system_update_keyspace_args = function(args) {
  this.ks_def = null;
  if (args) {
    if (args.ks_def !== undefined) {
      this.ks_def = args.ks_def;
    }
  }
};
Cassandra_system_update_keyspace_args.prototype = {};
Cassandra_system_update_keyspace_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ks_def = new ttypes.KsDef();
        this.ks_def.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_system_update_keyspace_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_system_update_keyspace_args');
  if (this.ks_def) {
    output.writeFieldBegin('ks_def', Thrift.Type.STRUCT, 1);
    this.ks_def.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_system_update_keyspace_result = function(args) {
  this.success = null;
  this.ire = null;
  this.sde = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.sde !== undefined) {
      this.sde = args.sde;
    }
  }
};
Cassandra_system_update_keyspace_result.prototype = {};
Cassandra_system_update_keyspace_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.STRING) {
        this.success = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.sde = new ttypes.SchemaDisagreementException();
        this.sde.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_system_update_keyspace_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_system_update_keyspace_result');
  if (this.success) {
    output.writeFieldBegin('success', Thrift.Type.STRING, 0);
    output.writeString(this.success);
    output.writeFieldEnd();
  }
  if (this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.sde) {
    output.writeFieldBegin('sde', Thrift.Type.STRUCT, 2);
    this.sde.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_system_update_column_family_args = function(args) {
  this.cf_def = null;
  if (args) {
    if (args.cf_def !== undefined) {
      this.cf_def = args.cf_def;
    }
  }
};
Cassandra_system_update_column_family_args.prototype = {};
Cassandra_system_update_column_family_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.cf_def = new ttypes.CfDef();
        this.cf_def.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_system_update_column_family_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_system_update_column_family_args');
  if (this.cf_def) {
    output.writeFieldBegin('cf_def', Thrift.Type.STRUCT, 1);
    this.cf_def.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_system_update_column_family_result = function(args) {
  this.success = null;
  this.ire = null;
  this.sde = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.sde !== undefined) {
      this.sde = args.sde;
    }
  }
};
Cassandra_system_update_column_family_result.prototype = {};
Cassandra_system_update_column_family_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.STRING) {
        this.success = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.sde = new ttypes.SchemaDisagreementException();
        this.sde.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_system_update_column_family_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_system_update_column_family_result');
  if (this.success) {
    output.writeFieldBegin('success', Thrift.Type.STRING, 0);
    output.writeString(this.success);
    output.writeFieldEnd();
  }
  if (this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.sde) {
    output.writeFieldBegin('sde', Thrift.Type.STRUCT, 2);
    this.sde.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_execute_cql_query_args = function(args) {
  this.query = null;
  this.compression = null;
  if (args) {
    if (args.query !== undefined) {
      this.query = args.query;
    }
    if (args.compression !== undefined) {
      this.compression = args.compression;
    }
  }
};
Cassandra_execute_cql_query_args.prototype = {};
Cassandra_execute_cql_query_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.query = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I32) {
        this.compression = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_execute_cql_query_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_execute_cql_query_args');
  if (this.query) {
    output.writeFieldBegin('query', Thrift.Type.STRING, 1);
    output.writeString(this.query);
    output.writeFieldEnd();
  }
  if (this.compression) {
    output.writeFieldBegin('compression', Thrift.Type.I32, 2);
    output.writeI32(this.compression);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_execute_cql_query_result = function(args) {
  this.success = null;
  this.ire = null;
  this.ue = null;
  this.te = null;
  this.sde = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.ue !== undefined) {
      this.ue = args.ue;
    }
    if (args.te !== undefined) {
      this.te = args.te;
    }
    if (args.sde !== undefined) {
      this.sde = args.sde;
    }
  }
};
Cassandra_execute_cql_query_result.prototype = {};
Cassandra_execute_cql_query_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.STRUCT) {
        this.success = new ttypes.CqlResult();
        this.success.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException();
        this.ue.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException();
        this.te.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.STRUCT) {
        this.sde = new ttypes.SchemaDisagreementException();
        this.sde.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_execute_cql_query_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_execute_cql_query_result');
  if (this.success) {
    output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
    this.success.write(output);
    output.writeFieldEnd();
  }
  if (this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.ue) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2);
    this.ue.write(output);
    output.writeFieldEnd();
  }
  if (this.te) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3);
    this.te.write(output);
    output.writeFieldEnd();
  }
  if (this.sde) {
    output.writeFieldBegin('sde', Thrift.Type.STRUCT, 4);
    this.sde.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_execute_cql3_query_args = function(args) {
  this.query = null;
  this.compression = null;
  this.consistency = null;
  if (args) {
    if (args.query !== undefined) {
      this.query = args.query;
    }
    if (args.compression !== undefined) {
      this.compression = args.compression;
    }
    if (args.consistency !== undefined) {
      this.consistency = args.consistency;
    }
  }
};
Cassandra_execute_cql3_query_args.prototype = {};
Cassandra_execute_cql3_query_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.query = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I32) {
        this.compression = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.I32) {
        this.consistency = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_execute_cql3_query_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_execute_cql3_query_args');
  if (this.query) {
    output.writeFieldBegin('query', Thrift.Type.STRING, 1);
    output.writeString(this.query);
    output.writeFieldEnd();
  }
  if (this.compression) {
    output.writeFieldBegin('compression', Thrift.Type.I32, 2);
    output.writeI32(this.compression);
    output.writeFieldEnd();
  }
  if (this.consistency) {
    output.writeFieldBegin('consistency', Thrift.Type.I32, 3);
    output.writeI32(this.consistency);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_execute_cql3_query_result = function(args) {
  this.success = null;
  this.ire = null;
  this.ue = null;
  this.te = null;
  this.sde = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.ue !== undefined) {
      this.ue = args.ue;
    }
    if (args.te !== undefined) {
      this.te = args.te;
    }
    if (args.sde !== undefined) {
      this.sde = args.sde;
    }
  }
};
Cassandra_execute_cql3_query_result.prototype = {};
Cassandra_execute_cql3_query_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.STRUCT) {
        this.success = new ttypes.CqlResult();
        this.success.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException();
        this.ue.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException();
        this.te.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.STRUCT) {
        this.sde = new ttypes.SchemaDisagreementException();
        this.sde.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_execute_cql3_query_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_execute_cql3_query_result');
  if (this.success) {
    output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
    this.success.write(output);
    output.writeFieldEnd();
  }
  if (this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.ue) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2);
    this.ue.write(output);
    output.writeFieldEnd();
  }
  if (this.te) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3);
    this.te.write(output);
    output.writeFieldEnd();
  }
  if (this.sde) {
    output.writeFieldBegin('sde', Thrift.Type.STRUCT, 4);
    this.sde.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_prepare_cql_query_args = function(args) {
  this.query = null;
  this.compression = null;
  if (args) {
    if (args.query !== undefined) {
      this.query = args.query;
    }
    if (args.compression !== undefined) {
      this.compression = args.compression;
    }
  }
};
Cassandra_prepare_cql_query_args.prototype = {};
Cassandra_prepare_cql_query_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.query = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I32) {
        this.compression = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_prepare_cql_query_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_prepare_cql_query_args');
  if (this.query) {
    output.writeFieldBegin('query', Thrift.Type.STRING, 1);
    output.writeString(this.query);
    output.writeFieldEnd();
  }
  if (this.compression) {
    output.writeFieldBegin('compression', Thrift.Type.I32, 2);
    output.writeI32(this.compression);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_prepare_cql_query_result = function(args) {
  this.success = null;
  this.ire = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
  }
};
Cassandra_prepare_cql_query_result.prototype = {};
Cassandra_prepare_cql_query_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.STRUCT) {
        this.success = new ttypes.CqlPreparedResult();
        this.success.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_prepare_cql_query_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_prepare_cql_query_result');
  if (this.success) {
    output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
    this.success.write(output);
    output.writeFieldEnd();
  }
  if (this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_prepare_cql3_query_args = function(args) {
  this.query = null;
  this.compression = null;
  if (args) {
    if (args.query !== undefined) {
      this.query = args.query;
    }
    if (args.compression !== undefined) {
      this.compression = args.compression;
    }
  }
};
Cassandra_prepare_cql3_query_args.prototype = {};
Cassandra_prepare_cql3_query_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.query = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I32) {
        this.compression = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_prepare_cql3_query_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_prepare_cql3_query_args');
  if (this.query) {
    output.writeFieldBegin('query', Thrift.Type.STRING, 1);
    output.writeString(this.query);
    output.writeFieldEnd();
  }
  if (this.compression) {
    output.writeFieldBegin('compression', Thrift.Type.I32, 2);
    output.writeI32(this.compression);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_prepare_cql3_query_result = function(args) {
  this.success = null;
  this.ire = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
  }
};
Cassandra_prepare_cql3_query_result.prototype = {};
Cassandra_prepare_cql3_query_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.STRUCT) {
        this.success = new ttypes.CqlPreparedResult();
        this.success.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_prepare_cql3_query_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_prepare_cql3_query_result');
  if (this.success) {
    output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
    this.success.write(output);
    output.writeFieldEnd();
  }
  if (this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_execute_prepared_cql_query_args = function(args) {
  this.itemId = null;
  this.values = null;
  if (args) {
    if (args.itemId !== undefined) {
      this.itemId = args.itemId;
    }
    if (args.values !== undefined) {
      this.values = args.values;
    }
  }
};
Cassandra_execute_prepared_cql_query_args.prototype = {};
Cassandra_execute_prepared_cql_query_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.itemId = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.LIST) {
        var _size382 = 0;
        var _rtmp3386;
        this.values = [];
        var _etype385 = 0;
        _rtmp3386 = input.readListBegin();
        _etype385 = _rtmp3386.etype;
        _size382 = _rtmp3386.size;
        for (var _i387 = 0; _i387 < _size382; ++_i387)
        {
          var elem388 = null;
          elem388 = input.readString();
          this.values.push(elem388);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_execute_prepared_cql_query_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_execute_prepared_cql_query_args');
  if (this.itemId) {
    output.writeFieldBegin('itemId', Thrift.Type.I32, 1);
    output.writeI32(this.itemId);
    output.writeFieldEnd();
  }
  if (this.values) {
    output.writeFieldBegin('values', Thrift.Type.LIST, 2);
    output.writeListBegin(Thrift.Type.STRING, this.values.length);
    for (var iter389 in this.values)
    {
      if (this.values.hasOwnProperty(iter389))
      {
        iter389 = this.values[iter389];
        output.writeString(iter389);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_execute_prepared_cql_query_result = function(args) {
  this.success = null;
  this.ire = null;
  this.ue = null;
  this.te = null;
  this.sde = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.ue !== undefined) {
      this.ue = args.ue;
    }
    if (args.te !== undefined) {
      this.te = args.te;
    }
    if (args.sde !== undefined) {
      this.sde = args.sde;
    }
  }
};
Cassandra_execute_prepared_cql_query_result.prototype = {};
Cassandra_execute_prepared_cql_query_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.STRUCT) {
        this.success = new ttypes.CqlResult();
        this.success.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException();
        this.ue.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException();
        this.te.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.STRUCT) {
        this.sde = new ttypes.SchemaDisagreementException();
        this.sde.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_execute_prepared_cql_query_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_execute_prepared_cql_query_result');
  if (this.success) {
    output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
    this.success.write(output);
    output.writeFieldEnd();
  }
  if (this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.ue) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2);
    this.ue.write(output);
    output.writeFieldEnd();
  }
  if (this.te) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3);
    this.te.write(output);
    output.writeFieldEnd();
  }
  if (this.sde) {
    output.writeFieldBegin('sde', Thrift.Type.STRUCT, 4);
    this.sde.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_execute_prepared_cql3_query_args = function(args) {
  this.itemId = null;
  this.values = null;
  this.consistency = null;
  if (args) {
    if (args.itemId !== undefined) {
      this.itemId = args.itemId;
    }
    if (args.values !== undefined) {
      this.values = args.values;
    }
    if (args.consistency !== undefined) {
      this.consistency = args.consistency;
    }
  }
};
Cassandra_execute_prepared_cql3_query_args.prototype = {};
Cassandra_execute_prepared_cql3_query_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.itemId = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.LIST) {
        var _size390 = 0;
        var _rtmp3394;
        this.values = [];
        var _etype393 = 0;
        _rtmp3394 = input.readListBegin();
        _etype393 = _rtmp3394.etype;
        _size390 = _rtmp3394.size;
        for (var _i395 = 0; _i395 < _size390; ++_i395)
        {
          var elem396 = null;
          elem396 = input.readString();
          this.values.push(elem396);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.I32) {
        this.consistency = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_execute_prepared_cql3_query_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_execute_prepared_cql3_query_args');
  if (this.itemId) {
    output.writeFieldBegin('itemId', Thrift.Type.I32, 1);
    output.writeI32(this.itemId);
    output.writeFieldEnd();
  }
  if (this.values) {
    output.writeFieldBegin('values', Thrift.Type.LIST, 2);
    output.writeListBegin(Thrift.Type.STRING, this.values.length);
    for (var iter397 in this.values)
    {
      if (this.values.hasOwnProperty(iter397))
      {
        iter397 = this.values[iter397];
        output.writeString(iter397);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.consistency) {
    output.writeFieldBegin('consistency', Thrift.Type.I32, 3);
    output.writeI32(this.consistency);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_execute_prepared_cql3_query_result = function(args) {
  this.success = null;
  this.ire = null;
  this.ue = null;
  this.te = null;
  this.sde = null;
  if (args) {
    if (args.success !== undefined) {
      this.success = args.success;
    }
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
    if (args.ue !== undefined) {
      this.ue = args.ue;
    }
    if (args.te !== undefined) {
      this.te = args.te;
    }
    if (args.sde !== undefined) {
      this.sde = args.sde;
    }
  }
};
Cassandra_execute_prepared_cql3_query_result.prototype = {};
Cassandra_execute_prepared_cql3_query_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
      if (ftype == Thrift.Type.STRUCT) {
        this.success = new ttypes.CqlResult();
        this.success.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.ue = new ttypes.UnavailableException();
        this.ue.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.te = new ttypes.TimedOutException();
        this.te.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.STRUCT) {
        this.sde = new ttypes.SchemaDisagreementException();
        this.sde.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_execute_prepared_cql3_query_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_execute_prepared_cql3_query_result');
  if (this.success) {
    output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
    this.success.write(output);
    output.writeFieldEnd();
  }
  if (this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  if (this.ue) {
    output.writeFieldBegin('ue', Thrift.Type.STRUCT, 2);
    this.ue.write(output);
    output.writeFieldEnd();
  }
  if (this.te) {
    output.writeFieldBegin('te', Thrift.Type.STRUCT, 3);
    this.te.write(output);
    output.writeFieldEnd();
  }
  if (this.sde) {
    output.writeFieldBegin('sde', Thrift.Type.STRUCT, 4);
    this.sde.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_set_cql_version_args = function(args) {
  this.version = null;
  if (args) {
    if (args.version !== undefined) {
      this.version = args.version;
    }
  }
};
Cassandra_set_cql_version_args.prototype = {};
Cassandra_set_cql_version_args.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.version = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_set_cql_version_args.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_set_cql_version_args');
  if (this.version) {
    output.writeFieldBegin('version', Thrift.Type.STRING, 1);
    output.writeString(this.version);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var Cassandra_set_cql_version_result = function(args) {
  this.ire = null;
  if (args) {
    if (args.ire !== undefined) {
      this.ire = args.ire;
    }
  }
};
Cassandra_set_cql_version_result.prototype = {};
Cassandra_set_cql_version_result.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ire = new ttypes.InvalidRequestException();
        this.ire.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

Cassandra_set_cql_version_result.prototype.write = function(output) {
  output.writeStructBegin('Cassandra_set_cql_version_result');
  if (this.ire) {
    output.writeFieldBegin('ire', Thrift.Type.STRUCT, 1);
    this.ire.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var CassandraClient = exports.Client = function(output, pClass) {
    this.output = output;
    this.pClass = pClass;
    this.seqid = 0;
    this._reqs = {};
};
CassandraClient.prototype = {};
CassandraClient.prototype.login = function(auth_request, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_login(auth_request);
};

CassandraClient.prototype.send_login = function(auth_request) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('login', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_login_args();
  args.auth_request = auth_request;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_login = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_login_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.authnx) {
    return callback(result.authnx);
  }
  if (null !== result.authzx) {
    return callback(result.authzx);
  }
  callback(null)
};
CassandraClient.prototype.set_keyspace = function(keyspace, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_set_keyspace(keyspace);
};

CassandraClient.prototype.send_set_keyspace = function(keyspace) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('set_keyspace', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_set_keyspace_args();
  args.keyspace = keyspace;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_set_keyspace = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_set_keyspace_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  callback(null)
};
CassandraClient.prototype.get = function(key, column_path, consistency_level, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_get(key, column_path, consistency_level);
};

CassandraClient.prototype.send_get = function(key, column_path, consistency_level) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('get', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_get_args();
  args.key = key;
  args.column_path = column_path;
  args.consistency_level = consistency_level;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_get = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_get_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.nfe) {
    return callback(result.nfe);
  }
  if (null !== result.ue) {
    return callback(result.ue);
  }
  if (null !== result.te) {
    return callback(result.te);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('get failed: unknown result');
};
CassandraClient.prototype.get_slice = function(key, column_parent, predicate, consistency_level, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_get_slice(key, column_parent, predicate, consistency_level);
};

CassandraClient.prototype.send_get_slice = function(key, column_parent, predicate, consistency_level) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('get_slice', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_get_slice_args();
  args.key = key;
  args.column_parent = column_parent;
  args.predicate = predicate;
  args.consistency_level = consistency_level;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_get_slice = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_get_slice_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.ue) {
    return callback(result.ue);
  }
  if (null !== result.te) {
    return callback(result.te);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('get_slice failed: unknown result');
};
CassandraClient.prototype.get_count = function(key, column_parent, predicate, consistency_level, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_get_count(key, column_parent, predicate, consistency_level);
};

CassandraClient.prototype.send_get_count = function(key, column_parent, predicate, consistency_level) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('get_count', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_get_count_args();
  args.key = key;
  args.column_parent = column_parent;
  args.predicate = predicate;
  args.consistency_level = consistency_level;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_get_count = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_get_count_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.ue) {
    return callback(result.ue);
  }
  if (null !== result.te) {
    return callback(result.te);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('get_count failed: unknown result');
};
CassandraClient.prototype.multiget_slice = function(keys, column_parent, predicate, consistency_level, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_multiget_slice(keys, column_parent, predicate, consistency_level);
};

CassandraClient.prototype.send_multiget_slice = function(keys, column_parent, predicate, consistency_level) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('multiget_slice', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_multiget_slice_args();
  args.keys = keys;
  args.column_parent = column_parent;
  args.predicate = predicate;
  args.consistency_level = consistency_level;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_multiget_slice = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_multiget_slice_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.ue) {
    return callback(result.ue);
  }
  if (null !== result.te) {
    return callback(result.te);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('multiget_slice failed: unknown result');
};
CassandraClient.prototype.multiget_count = function(keys, column_parent, predicate, consistency_level, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_multiget_count(keys, column_parent, predicate, consistency_level);
};

CassandraClient.prototype.send_multiget_count = function(keys, column_parent, predicate, consistency_level) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('multiget_count', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_multiget_count_args();
  args.keys = keys;
  args.column_parent = column_parent;
  args.predicate = predicate;
  args.consistency_level = consistency_level;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_multiget_count = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_multiget_count_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.ue) {
    return callback(result.ue);
  }
  if (null !== result.te) {
    return callback(result.te);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('multiget_count failed: unknown result');
};
CassandraClient.prototype.get_range_slices = function(column_parent, predicate, range, consistency_level, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_get_range_slices(column_parent, predicate, range, consistency_level);
};

CassandraClient.prototype.send_get_range_slices = function(column_parent, predicate, range, consistency_level) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('get_range_slices', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_get_range_slices_args();
  args.column_parent = column_parent;
  args.predicate = predicate;
  args.range = range;
  args.consistency_level = consistency_level;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_get_range_slices = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_get_range_slices_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.ue) {
    return callback(result.ue);
  }
  if (null !== result.te) {
    return callback(result.te);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('get_range_slices failed: unknown result');
};
CassandraClient.prototype.get_paged_slice = function(column_family, range, start_column, consistency_level, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_get_paged_slice(column_family, range, start_column, consistency_level);
};

CassandraClient.prototype.send_get_paged_slice = function(column_family, range, start_column, consistency_level) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('get_paged_slice', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_get_paged_slice_args();
  args.column_family = column_family;
  args.range = range;
  args.start_column = start_column;
  args.consistency_level = consistency_level;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_get_paged_slice = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_get_paged_slice_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.ue) {
    return callback(result.ue);
  }
  if (null !== result.te) {
    return callback(result.te);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('get_paged_slice failed: unknown result');
};
CassandraClient.prototype.get_indexed_slices = function(column_parent, index_clause, column_predicate, consistency_level, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_get_indexed_slices(column_parent, index_clause, column_predicate, consistency_level);
};

CassandraClient.prototype.send_get_indexed_slices = function(column_parent, index_clause, column_predicate, consistency_level) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('get_indexed_slices', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_get_indexed_slices_args();
  args.column_parent = column_parent;
  args.index_clause = index_clause;
  args.column_predicate = column_predicate;
  args.consistency_level = consistency_level;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_get_indexed_slices = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_get_indexed_slices_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.ue) {
    return callback(result.ue);
  }
  if (null !== result.te) {
    return callback(result.te);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('get_indexed_slices failed: unknown result');
};
CassandraClient.prototype.insert = function(key, column_parent, column, consistency_level, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_insert(key, column_parent, column, consistency_level);
};

CassandraClient.prototype.send_insert = function(key, column_parent, column, consistency_level) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('insert', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_insert_args();
  args.key = key;
  args.column_parent = column_parent;
  args.column = column;
  args.consistency_level = consistency_level;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_insert = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_insert_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.ue) {
    return callback(result.ue);
  }
  if (null !== result.te) {
    return callback(result.te);
  }
  callback(null)
};
CassandraClient.prototype.add = function(key, column_parent, column, consistency_level, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_add(key, column_parent, column, consistency_level);
};

CassandraClient.prototype.send_add = function(key, column_parent, column, consistency_level) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('add', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_add_args();
  args.key = key;
  args.column_parent = column_parent;
  args.column = column;
  args.consistency_level = consistency_level;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_add = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_add_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.ue) {
    return callback(result.ue);
  }
  if (null !== result.te) {
    return callback(result.te);
  }
  callback(null)
};
CassandraClient.prototype.remove = function(key, column_path, timestamp, consistency_level, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_remove(key, column_path, timestamp, consistency_level);
};

CassandraClient.prototype.send_remove = function(key, column_path, timestamp, consistency_level) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('remove', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_remove_args();
  args.key = key;
  args.column_path = column_path;
  args.timestamp = timestamp;
  args.consistency_level = consistency_level;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_remove = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_remove_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.ue) {
    return callback(result.ue);
  }
  if (null !== result.te) {
    return callback(result.te);
  }
  callback(null)
};
CassandraClient.prototype.remove_counter = function(key, path, consistency_level, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_remove_counter(key, path, consistency_level);
};

CassandraClient.prototype.send_remove_counter = function(key, path, consistency_level) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('remove_counter', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_remove_counter_args();
  args.key = key;
  args.path = path;
  args.consistency_level = consistency_level;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_remove_counter = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_remove_counter_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.ue) {
    return callback(result.ue);
  }
  if (null !== result.te) {
    return callback(result.te);
  }
  callback(null)
};
CassandraClient.prototype.batch_mutate = function(mutation_map, consistency_level, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_batch_mutate(mutation_map, consistency_level);
};

CassandraClient.prototype.send_batch_mutate = function(mutation_map, consistency_level) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('batch_mutate', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_batch_mutate_args();
  args.mutation_map = mutation_map;
  args.consistency_level = consistency_level;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_batch_mutate = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_batch_mutate_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.ue) {
    return callback(result.ue);
  }
  if (null !== result.te) {
    return callback(result.te);
  }
  callback(null)
};
CassandraClient.prototype.atomic_batch_mutate = function(mutation_map, consistency_level, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_atomic_batch_mutate(mutation_map, consistency_level);
};

CassandraClient.prototype.send_atomic_batch_mutate = function(mutation_map, consistency_level) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('atomic_batch_mutate', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_atomic_batch_mutate_args();
  args.mutation_map = mutation_map;
  args.consistency_level = consistency_level;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_atomic_batch_mutate = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_atomic_batch_mutate_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.ue) {
    return callback(result.ue);
  }
  if (null !== result.te) {
    return callback(result.te);
  }
  callback(null)
};
CassandraClient.prototype.truncate = function(cfname, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_truncate(cfname);
};

CassandraClient.prototype.send_truncate = function(cfname) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('truncate', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_truncate_args();
  args.cfname = cfname;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_truncate = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_truncate_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.ue) {
    return callback(result.ue);
  }
  if (null !== result.te) {
    return callback(result.te);
  }
  callback(null)
};
CassandraClient.prototype.describe_schema_versions = function(callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_describe_schema_versions();
};

CassandraClient.prototype.send_describe_schema_versions = function() {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('describe_schema_versions', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_describe_schema_versions_args();
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_describe_schema_versions = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_describe_schema_versions_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('describe_schema_versions failed: unknown result');
};
CassandraClient.prototype.describe_keyspaces = function(callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_describe_keyspaces();
};

CassandraClient.prototype.send_describe_keyspaces = function() {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('describe_keyspaces', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_describe_keyspaces_args();
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_describe_keyspaces = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_describe_keyspaces_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('describe_keyspaces failed: unknown result');
};
CassandraClient.prototype.describe_cluster_name = function(callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_describe_cluster_name();
};

CassandraClient.prototype.send_describe_cluster_name = function() {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('describe_cluster_name', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_describe_cluster_name_args();
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_describe_cluster_name = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_describe_cluster_name_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('describe_cluster_name failed: unknown result');
};
CassandraClient.prototype.describe_version = function(callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_describe_version();
};

CassandraClient.prototype.send_describe_version = function() {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('describe_version', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_describe_version_args();
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_describe_version = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_describe_version_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('describe_version failed: unknown result');
};
CassandraClient.prototype.describe_ring = function(keyspace, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_describe_ring(keyspace);
};

CassandraClient.prototype.send_describe_ring = function(keyspace) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('describe_ring', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_describe_ring_args();
  args.keyspace = keyspace;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_describe_ring = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_describe_ring_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('describe_ring failed: unknown result');
};
CassandraClient.prototype.describe_token_map = function(callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_describe_token_map();
};

CassandraClient.prototype.send_describe_token_map = function() {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('describe_token_map', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_describe_token_map_args();
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_describe_token_map = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_describe_token_map_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('describe_token_map failed: unknown result');
};
CassandraClient.prototype.describe_partitioner = function(callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_describe_partitioner();
};

CassandraClient.prototype.send_describe_partitioner = function() {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('describe_partitioner', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_describe_partitioner_args();
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_describe_partitioner = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_describe_partitioner_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('describe_partitioner failed: unknown result');
};
CassandraClient.prototype.describe_snitch = function(callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_describe_snitch();
};

CassandraClient.prototype.send_describe_snitch = function() {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('describe_snitch', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_describe_snitch_args();
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_describe_snitch = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_describe_snitch_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('describe_snitch failed: unknown result');
};
CassandraClient.prototype.describe_keyspace = function(keyspace, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_describe_keyspace(keyspace);
};

CassandraClient.prototype.send_describe_keyspace = function(keyspace) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('describe_keyspace', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_describe_keyspace_args();
  args.keyspace = keyspace;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_describe_keyspace = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_describe_keyspace_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.nfe) {
    return callback(result.nfe);
  }
  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('describe_keyspace failed: unknown result');
};
CassandraClient.prototype.describe_splits = function(cfName, start_token, end_token, keys_per_split, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_describe_splits(cfName, start_token, end_token, keys_per_split);
};

CassandraClient.prototype.send_describe_splits = function(cfName, start_token, end_token, keys_per_split) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('describe_splits', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_describe_splits_args();
  args.cfName = cfName;
  args.start_token = start_token;
  args.end_token = end_token;
  args.keys_per_split = keys_per_split;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_describe_splits = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_describe_splits_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('describe_splits failed: unknown result');
};
CassandraClient.prototype.trace_next_query = function(callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_trace_next_query();
};

CassandraClient.prototype.send_trace_next_query = function() {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('trace_next_query', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_trace_next_query_args();
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_trace_next_query = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_trace_next_query_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('trace_next_query failed: unknown result');
};
CassandraClient.prototype.describe_splits_ex = function(cfName, start_token, end_token, keys_per_split, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_describe_splits_ex(cfName, start_token, end_token, keys_per_split);
};

CassandraClient.prototype.send_describe_splits_ex = function(cfName, start_token, end_token, keys_per_split) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('describe_splits_ex', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_describe_splits_ex_args();
  args.cfName = cfName;
  args.start_token = start_token;
  args.end_token = end_token;
  args.keys_per_split = keys_per_split;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_describe_splits_ex = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_describe_splits_ex_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('describe_splits_ex failed: unknown result');
};
CassandraClient.prototype.system_add_column_family = function(cf_def, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_system_add_column_family(cf_def);
};

CassandraClient.prototype.send_system_add_column_family = function(cf_def) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('system_add_column_family', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_system_add_column_family_args();
  args.cf_def = cf_def;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_system_add_column_family = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_system_add_column_family_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.sde) {
    return callback(result.sde);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('system_add_column_family failed: unknown result');
};
CassandraClient.prototype.system_drop_column_family = function(column_family, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_system_drop_column_family(column_family);
};

CassandraClient.prototype.send_system_drop_column_family = function(column_family) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('system_drop_column_family', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_system_drop_column_family_args();
  args.column_family = column_family;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_system_drop_column_family = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_system_drop_column_family_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.sde) {
    return callback(result.sde);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('system_drop_column_family failed: unknown result');
};
CassandraClient.prototype.system_add_keyspace = function(ks_def, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_system_add_keyspace(ks_def);
};

CassandraClient.prototype.send_system_add_keyspace = function(ks_def) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('system_add_keyspace', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_system_add_keyspace_args();
  args.ks_def = ks_def;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_system_add_keyspace = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_system_add_keyspace_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.sde) {
    return callback(result.sde);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('system_add_keyspace failed: unknown result');
};
CassandraClient.prototype.system_drop_keyspace = function(keyspace, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_system_drop_keyspace(keyspace);
};

CassandraClient.prototype.send_system_drop_keyspace = function(keyspace) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('system_drop_keyspace', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_system_drop_keyspace_args();
  args.keyspace = keyspace;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_system_drop_keyspace = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_system_drop_keyspace_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.sde) {
    return callback(result.sde);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('system_drop_keyspace failed: unknown result');
};
CassandraClient.prototype.system_update_keyspace = function(ks_def, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_system_update_keyspace(ks_def);
};

CassandraClient.prototype.send_system_update_keyspace = function(ks_def) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('system_update_keyspace', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_system_update_keyspace_args();
  args.ks_def = ks_def;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_system_update_keyspace = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_system_update_keyspace_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.sde) {
    return callback(result.sde);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('system_update_keyspace failed: unknown result');
};
CassandraClient.prototype.system_update_column_family = function(cf_def, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_system_update_column_family(cf_def);
};

CassandraClient.prototype.send_system_update_column_family = function(cf_def) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('system_update_column_family', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_system_update_column_family_args();
  args.cf_def = cf_def;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_system_update_column_family = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_system_update_column_family_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.sde) {
    return callback(result.sde);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('system_update_column_family failed: unknown result');
};
CassandraClient.prototype.execute_cql_query = function(query, compression, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_execute_cql_query(query, compression);
};

CassandraClient.prototype.send_execute_cql_query = function(query, compression) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('execute_cql_query', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_execute_cql_query_args();
  args.query = query;
  args.compression = compression;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_execute_cql_query = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_execute_cql_query_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.ue) {
    return callback(result.ue);
  }
  if (null !== result.te) {
    return callback(result.te);
  }
  if (null !== result.sde) {
    return callback(result.sde);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('execute_cql_query failed: unknown result');
};
CassandraClient.prototype.execute_cql3_query = function(query, compression, consistency, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_execute_cql3_query(query, compression, consistency);
};

CassandraClient.prototype.send_execute_cql3_query = function(query, compression, consistency) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('execute_cql3_query', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_execute_cql3_query_args();
  args.query = query;
  args.compression = compression;
  args.consistency = consistency;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_execute_cql3_query = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_execute_cql3_query_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.ue) {
    return callback(result.ue);
  }
  if (null !== result.te) {
    return callback(result.te);
  }
  if (null !== result.sde) {
    return callback(result.sde);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('execute_cql3_query failed: unknown result');
};
CassandraClient.prototype.prepare_cql_query = function(query, compression, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_prepare_cql_query(query, compression);
};

CassandraClient.prototype.send_prepare_cql_query = function(query, compression) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('prepare_cql_query', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_prepare_cql_query_args();
  args.query = query;
  args.compression = compression;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_prepare_cql_query = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_prepare_cql_query_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('prepare_cql_query failed: unknown result');
};
CassandraClient.prototype.prepare_cql3_query = function(query, compression, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_prepare_cql3_query(query, compression);
};

CassandraClient.prototype.send_prepare_cql3_query = function(query, compression) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('prepare_cql3_query', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_prepare_cql3_query_args();
  args.query = query;
  args.compression = compression;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_prepare_cql3_query = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_prepare_cql3_query_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('prepare_cql3_query failed: unknown result');
};
CassandraClient.prototype.execute_prepared_cql_query = function(itemId, values, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_execute_prepared_cql_query(itemId, values);
};

CassandraClient.prototype.send_execute_prepared_cql_query = function(itemId, values) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('execute_prepared_cql_query', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_execute_prepared_cql_query_args();
  args.itemId = itemId;
  args.values = values;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_execute_prepared_cql_query = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_execute_prepared_cql_query_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.ue) {
    return callback(result.ue);
  }
  if (null !== result.te) {
    return callback(result.te);
  }
  if (null !== result.sde) {
    return callback(result.sde);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('execute_prepared_cql_query failed: unknown result');
};
CassandraClient.prototype.execute_prepared_cql3_query = function(itemId, values, consistency, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_execute_prepared_cql3_query(itemId, values, consistency);
};

CassandraClient.prototype.send_execute_prepared_cql3_query = function(itemId, values, consistency) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('execute_prepared_cql3_query', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_execute_prepared_cql3_query_args();
  args.itemId = itemId;
  args.values = values;
  args.consistency = consistency;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_execute_prepared_cql3_query = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_execute_prepared_cql3_query_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  if (null !== result.ue) {
    return callback(result.ue);
  }
  if (null !== result.te) {
    return callback(result.te);
  }
  if (null !== result.sde) {
    return callback(result.sde);
  }
  if (null !== result.success) {
    return callback(null, result.success);
  }
  return callback('execute_prepared_cql3_query failed: unknown result');
};
CassandraClient.prototype.set_cql_version = function(version, callback) {
  this.seqid += 1;
  this._reqs[this.seqid] = callback;
  this.send_set_cql_version(version);
};

CassandraClient.prototype.send_set_cql_version = function(version) {
  var output = new this.pClass(this.output);
  output.writeMessageBegin('set_cql_version', Thrift.MessageType.CALL, this.seqid);
  var args = new Cassandra_set_cql_version_args();
  args.version = version;
  args.write(output);
  output.writeMessageEnd();
  return this.output.flush();
};

CassandraClient.prototype.recv_set_cql_version = function(input,mtype,rseqid) {
  var callback = this._reqs[rseqid] || function() {};
  delete this._reqs[rseqid];
  if (mtype == Thrift.MessageType.EXCEPTION) {
    var x = new Thrift.TApplicationException();
    x.read(input);
    input.readMessageEnd();
    return callback(x);
  }
  var result = new Cassandra_set_cql_version_result();
  result.read(input);
  input.readMessageEnd();

  if (null !== result.ire) {
    return callback(result.ire);
  }
  callback(null)
};
var CassandraProcessor = exports.Processor = function(handler) {
  this._handler = handler
}
CassandraProcessor.prototype.process = function(input, output) {
  var r = input.readMessageBegin();
  if (this['process_' + r.fname]) {
    return this['process_' + r.fname].call(this, r.rseqid, input, output);
  } else {
    input.skip(Thrift.Type.STRUCT);
    input.readMessageEnd();
    var x = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN_METHOD, 'Unknown function ' + r.fname);
    output.writeMessageBegin(r.fname, Thrift.MessageType.Exception, r.rseqid);
    x.write(output);
    output.writeMessageEnd();
    output.flush();
  }
}

CassandraProcessor.prototype.process_login = function(seqid, input, output) {
  var args = new Cassandra_login_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_login_result();
  this._handler.login(args.auth_request, function (success) {
    result.success = success;
    output.writeMessageBegin("login", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_set_keyspace = function(seqid, input, output) {
  var args = new Cassandra_set_keyspace_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_set_keyspace_result();
  this._handler.set_keyspace(args.keyspace, function (success) {
    result.success = success;
    output.writeMessageBegin("set_keyspace", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_get = function(seqid, input, output) {
  var args = new Cassandra_get_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_get_result();
  this._handler.get(args.key, args.column_path, args.consistency_level, function (success) {
    result.success = success;
    output.writeMessageBegin("get", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_get_slice = function(seqid, input, output) {
  var args = new Cassandra_get_slice_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_get_slice_result();
  this._handler.get_slice(args.key, args.column_parent, args.predicate, args.consistency_level, function (success) {
    result.success = success;
    output.writeMessageBegin("get_slice", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_get_count = function(seqid, input, output) {
  var args = new Cassandra_get_count_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_get_count_result();
  this._handler.get_count(args.key, args.column_parent, args.predicate, args.consistency_level, function (success) {
    result.success = success;
    output.writeMessageBegin("get_count", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_multiget_slice = function(seqid, input, output) {
  var args = new Cassandra_multiget_slice_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_multiget_slice_result();
  this._handler.multiget_slice(args.keys, args.column_parent, args.predicate, args.consistency_level, function (success) {
    result.success = success;
    output.writeMessageBegin("multiget_slice", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_multiget_count = function(seqid, input, output) {
  var args = new Cassandra_multiget_count_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_multiget_count_result();
  this._handler.multiget_count(args.keys, args.column_parent, args.predicate, args.consistency_level, function (success) {
    result.success = success;
    output.writeMessageBegin("multiget_count", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_get_range_slices = function(seqid, input, output) {
  var args = new Cassandra_get_range_slices_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_get_range_slices_result();
  this._handler.get_range_slices(args.column_parent, args.predicate, args.range, args.consistency_level, function (success) {
    result.success = success;
    output.writeMessageBegin("get_range_slices", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_get_paged_slice = function(seqid, input, output) {
  var args = new Cassandra_get_paged_slice_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_get_paged_slice_result();
  this._handler.get_paged_slice(args.column_family, args.range, args.start_column, args.consistency_level, function (success) {
    result.success = success;
    output.writeMessageBegin("get_paged_slice", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_get_indexed_slices = function(seqid, input, output) {
  var args = new Cassandra_get_indexed_slices_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_get_indexed_slices_result();
  this._handler.get_indexed_slices(args.column_parent, args.index_clause, args.column_predicate, args.consistency_level, function (success) {
    result.success = success;
    output.writeMessageBegin("get_indexed_slices", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_insert = function(seqid, input, output) {
  var args = new Cassandra_insert_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_insert_result();
  this._handler.insert(args.key, args.column_parent, args.column, args.consistency_level, function (success) {
    result.success = success;
    output.writeMessageBegin("insert", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_add = function(seqid, input, output) {
  var args = new Cassandra_add_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_add_result();
  this._handler.add(args.key, args.column_parent, args.column, args.consistency_level, function (success) {
    result.success = success;
    output.writeMessageBegin("add", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_remove = function(seqid, input, output) {
  var args = new Cassandra_remove_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_remove_result();
  this._handler.remove(args.key, args.column_path, args.timestamp, args.consistency_level, function (success) {
    result.success = success;
    output.writeMessageBegin("remove", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_remove_counter = function(seqid, input, output) {
  var args = new Cassandra_remove_counter_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_remove_counter_result();
  this._handler.remove_counter(args.key, args.path, args.consistency_level, function (success) {
    result.success = success;
    output.writeMessageBegin("remove_counter", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_batch_mutate = function(seqid, input, output) {
  var args = new Cassandra_batch_mutate_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_batch_mutate_result();
  this._handler.batch_mutate(args.mutation_map, args.consistency_level, function (success) {
    result.success = success;
    output.writeMessageBegin("batch_mutate", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_atomic_batch_mutate = function(seqid, input, output) {
  var args = new Cassandra_atomic_batch_mutate_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_atomic_batch_mutate_result();
  this._handler.atomic_batch_mutate(args.mutation_map, args.consistency_level, function (success) {
    result.success = success;
    output.writeMessageBegin("atomic_batch_mutate", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_truncate = function(seqid, input, output) {
  var args = new Cassandra_truncate_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_truncate_result();
  this._handler.truncate(args.cfname, function (success) {
    result.success = success;
    output.writeMessageBegin("truncate", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_describe_schema_versions = function(seqid, input, output) {
  var args = new Cassandra_describe_schema_versions_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_describe_schema_versions_result();
  this._handler.describe_schema_versions(function (success) {
    result.success = success;
    output.writeMessageBegin("describe_schema_versions", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_describe_keyspaces = function(seqid, input, output) {
  var args = new Cassandra_describe_keyspaces_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_describe_keyspaces_result();
  this._handler.describe_keyspaces(function (success) {
    result.success = success;
    output.writeMessageBegin("describe_keyspaces", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_describe_cluster_name = function(seqid, input, output) {
  var args = new Cassandra_describe_cluster_name_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_describe_cluster_name_result();
  this._handler.describe_cluster_name(function (success) {
    result.success = success;
    output.writeMessageBegin("describe_cluster_name", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_describe_version = function(seqid, input, output) {
  var args = new Cassandra_describe_version_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_describe_version_result();
  this._handler.describe_version(function (success) {
    result.success = success;
    output.writeMessageBegin("describe_version", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_describe_ring = function(seqid, input, output) {
  var args = new Cassandra_describe_ring_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_describe_ring_result();
  this._handler.describe_ring(args.keyspace, function (success) {
    result.success = success;
    output.writeMessageBegin("describe_ring", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_describe_token_map = function(seqid, input, output) {
  var args = new Cassandra_describe_token_map_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_describe_token_map_result();
  this._handler.describe_token_map(function (success) {
    result.success = success;
    output.writeMessageBegin("describe_token_map", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_describe_partitioner = function(seqid, input, output) {
  var args = new Cassandra_describe_partitioner_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_describe_partitioner_result();
  this._handler.describe_partitioner(function (success) {
    result.success = success;
    output.writeMessageBegin("describe_partitioner", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_describe_snitch = function(seqid, input, output) {
  var args = new Cassandra_describe_snitch_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_describe_snitch_result();
  this._handler.describe_snitch(function (success) {
    result.success = success;
    output.writeMessageBegin("describe_snitch", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_describe_keyspace = function(seqid, input, output) {
  var args = new Cassandra_describe_keyspace_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_describe_keyspace_result();
  this._handler.describe_keyspace(args.keyspace, function (success) {
    result.success = success;
    output.writeMessageBegin("describe_keyspace", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_describe_splits = function(seqid, input, output) {
  var args = new Cassandra_describe_splits_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_describe_splits_result();
  this._handler.describe_splits(args.cfName, args.start_token, args.end_token, args.keys_per_split, function (success) {
    result.success = success;
    output.writeMessageBegin("describe_splits", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_trace_next_query = function(seqid, input, output) {
  var args = new Cassandra_trace_next_query_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_trace_next_query_result();
  this._handler.trace_next_query(function (success) {
    result.success = success;
    output.writeMessageBegin("trace_next_query", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_describe_splits_ex = function(seqid, input, output) {
  var args = new Cassandra_describe_splits_ex_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_describe_splits_ex_result();
  this._handler.describe_splits_ex(args.cfName, args.start_token, args.end_token, args.keys_per_split, function (success) {
    result.success = success;
    output.writeMessageBegin("describe_splits_ex", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_system_add_column_family = function(seqid, input, output) {
  var args = new Cassandra_system_add_column_family_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_system_add_column_family_result();
  this._handler.system_add_column_family(args.cf_def, function (success) {
    result.success = success;
    output.writeMessageBegin("system_add_column_family", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_system_drop_column_family = function(seqid, input, output) {
  var args = new Cassandra_system_drop_column_family_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_system_drop_column_family_result();
  this._handler.system_drop_column_family(args.column_family, function (success) {
    result.success = success;
    output.writeMessageBegin("system_drop_column_family", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_system_add_keyspace = function(seqid, input, output) {
  var args = new Cassandra_system_add_keyspace_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_system_add_keyspace_result();
  this._handler.system_add_keyspace(args.ks_def, function (success) {
    result.success = success;
    output.writeMessageBegin("system_add_keyspace", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_system_drop_keyspace = function(seqid, input, output) {
  var args = new Cassandra_system_drop_keyspace_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_system_drop_keyspace_result();
  this._handler.system_drop_keyspace(args.keyspace, function (success) {
    result.success = success;
    output.writeMessageBegin("system_drop_keyspace", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_system_update_keyspace = function(seqid, input, output) {
  var args = new Cassandra_system_update_keyspace_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_system_update_keyspace_result();
  this._handler.system_update_keyspace(args.ks_def, function (success) {
    result.success = success;
    output.writeMessageBegin("system_update_keyspace", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_system_update_column_family = function(seqid, input, output) {
  var args = new Cassandra_system_update_column_family_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_system_update_column_family_result();
  this._handler.system_update_column_family(args.cf_def, function (success) {
    result.success = success;
    output.writeMessageBegin("system_update_column_family", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_execute_cql_query = function(seqid, input, output) {
  var args = new Cassandra_execute_cql_query_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_execute_cql_query_result();
  this._handler.execute_cql_query(args.query, args.compression, function (success) {
    result.success = success;
    output.writeMessageBegin("execute_cql_query", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_execute_cql3_query = function(seqid, input, output) {
  var args = new Cassandra_execute_cql3_query_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_execute_cql3_query_result();
  this._handler.execute_cql3_query(args.query, args.compression, args.consistency, function (success) {
    result.success = success;
    output.writeMessageBegin("execute_cql3_query", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_prepare_cql_query = function(seqid, input, output) {
  var args = new Cassandra_prepare_cql_query_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_prepare_cql_query_result();
  this._handler.prepare_cql_query(args.query, args.compression, function (success) {
    result.success = success;
    output.writeMessageBegin("prepare_cql_query", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_prepare_cql3_query = function(seqid, input, output) {
  var args = new Cassandra_prepare_cql3_query_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_prepare_cql3_query_result();
  this._handler.prepare_cql3_query(args.query, args.compression, function (success) {
    result.success = success;
    output.writeMessageBegin("prepare_cql3_query", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_execute_prepared_cql_query = function(seqid, input, output) {
  var args = new Cassandra_execute_prepared_cql_query_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_execute_prepared_cql_query_result();
  this._handler.execute_prepared_cql_query(args.itemId, args.values, function (success) {
    result.success = success;
    output.writeMessageBegin("execute_prepared_cql_query", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_execute_prepared_cql3_query = function(seqid, input, output) {
  var args = new Cassandra_execute_prepared_cql3_query_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_execute_prepared_cql3_query_result();
  this._handler.execute_prepared_cql3_query(args.itemId, args.values, args.consistency, function (success) {
    result.success = success;
    output.writeMessageBegin("execute_prepared_cql3_query", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

CassandraProcessor.prototype.process_set_cql_version = function(seqid, input, output) {
  var args = new Cassandra_set_cql_version_args();
  args.read(input);
  input.readMessageEnd();
  var result = new Cassandra_set_cql_version_result();
  this._handler.set_cql_version(args.version, function (success) {
    result.success = success;
    output.writeMessageBegin("set_cql_version", Thrift.MessageType.REPLY, seqid);
    result.write(output);
    output.writeMessageEnd();
    output.flush();
  })
}

